<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Museum‑Grade Photo &amp; Video UI — v1.10.4 (drop‑box reorder &amp; sequence index)</title>
<style>
  :root{
    --bg:#0f1115; --stroke:rgba(255,255,255,.18); --text:rgba(255,255,255,.88);
    --muted:rgba(255,255,255,.65); --radius:18px; --accent:#d7c29f;
    --gray:1; --blur:0px;
    --resize-ease: cubic-bezier(0.23, 1, 0.32, 1);
    --ctrl-scale: 1;
    --ctrl-bottom: 18px;
  }
  *{box-sizing:border-box}
  /* Invisible scrollbars */
  .stage, .caption-panel, .caption-text { scrollbar-width: none; -ms-overflow-style: none; }
  .stage::-webkit-scrollbar, .caption-panel::-webkit-scrollbar, .caption-text::-webkit-scrollbar { width: 0; height: 0; }

  body{
    margin:0; color:var(--text);
    font:15px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial;
    background:
      radial-gradient(1200px 800px at 70% 10%, rgba(215,194,159,.18), transparent 60%),
      radial-gradient(900px 600px at 10% 90%, rgba(255,240,220,.12), transparent 60%),
      linear-gradient(180deg,#0b0d12,#0f1115);
  }
  .wrap{display:grid;grid-template-columns:420px 1fr;gap:28px;min-height:100vh;padding:28px}
  .panel {
  padding:22px;
  border-radius:var(--radius);
  border:1px solid var(--stroke);
  text-align:center;
  /* Solid dark base + layered gradients for texture */
  background:
    radial-gradient(800px 600px at 80% 0%, rgba(215,194,159,.08), transparent 60%),
    radial-gradient(600px 400px at 10% 100%, rgba(255,240,220,.06), transparent 60%),
    linear-gradient(180deg, #13161c, #0f1115);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 12px 40px rgba(0,0,0,.35);
}
  .panel h1{margin:0 0 10px;font-size:18px;letter-spacing:.08em;text-transform:uppercase;color:var(--muted)}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:12px;padding:8px 0}
  .btn,.chip{display:inline-flex;align-items:center;gap:10px;padding:10px 14px;border-radius:999px;border:1px solid var(--stroke);background:rgba(255,255,255,.06);color:var(--text);cursor:pointer;user-select:none;text-decoration:none}
  .btn .dot,.chip .dot{width:8px;height:8px;border-radius:50%;background:var(--accent);box-shadow:0 0 16px var(--accent)}
  .chip.active{background:rgba(215,194,159,.14);border-color:rgba(215,194,159,.5)}

  /* === Impression Dial === */
  .dial{
    --ring: rgba(255,255,255,.14);
    position:relative;
    width:var(--dial-size); height:var(--dial-size); margin:8px auto 6px;
    border-radius:50%;
    background:
      radial-gradient(120px 120px at 50% 50%, rgba(255,255,255,.06), rgba(255,255,255,.02) 60%, transparent 61%),
      conic-gradient(from 0deg, rgba(215,194,159,.25), rgba(215,194,159,.05) 120deg, rgba(255,255,255,.08) 240deg, rgba(215,194,159,.25) 360deg);
    border:1px solid var(--stroke);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.04), 0 8px 26px rgba(0,0,0,.35);
    cursor:grab;
    user-select:none;
  }
  .dial.dragging{ cursor:grabbing; }
  .dial::after{ /* center hub */
    content:"";
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:16px; height:16px; border-radius:50%;
    background:radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.2) 35%, rgba(255,255,255,.06) 60%);
    border:1px solid rgba(255,255,255,.5);
    box-shadow:0 2px 10px rgba(0,0,0,.45);
  }
  .needle{
    --angle: 0deg;
    position:absolute; left:50%; top:50%;
    width:4px; height:42%;
    transform-origin:50% 100%;
    transform: translate(-50%, -100%) rotate(var(--angle));
    background: linear-gradient(to top, rgba(215,194,159,1), rgba(215,194,159,.15));
    border-radius:3px;
    box-shadow: 0 0 10px rgba(215,194,159,.55);
  }
  .label{ font-size:13px; color:var(--muted); margin:4px 0 10px; }

  .stage{position:relative;border-radius:var(--radius);border:1px solid var(--stroke);background:rgba(255,255,255,.02);display:flex;flex-direction:column;overflow:auto;max-height:calc(100vh - 56px)}
  .grid{flex:1;display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:18px;padding:18px;filter:grayscale(var(--gray)) blur(var(--blur))}
  @media (max-width:1200px){.grid{grid-template-columns:repeat(auto-fill,minmax(260px,1fr))}}
  @media (max-width:900px){.wrap{grid-template-columns:1fr}.panel{order:2}.stage{max-height:none}}

  .tile{position:relative;aspect-ratio:1/1;border-radius:16px;overflow:hidden;box-shadow:0 8px 20px rgba(0,0,0,.35);transition:transform .25s ease,box-shadow .25s ease,outline-color .25s;outline:1px solid rgba(255,255,255,.06)}
  .tile:hover{transform:translateY(-2px);box-shadow:0 18px 40px rgba(0,0,0,.45);outline-color:rgba(255,255,255,.16)}
  .tile.size-2{grid-column:span 2;grid-row:span 2}
.tile.size-3{grid-column:span 3;grid-row:span 3}
  .tile img,.tile video{width:100%;height:100%;object-fit:cover;display:block;cursor:zoom-in;
  -webkit-user-drag: none;

  user-select: none;
}
  .tile video{filter:saturate(1.05)}
  /* Sequence badge */
  .seq-badge{position:absolute;left:8px;top:8px;min-width:22px;height:22px;border-radius:999px;display:none;place-items:center;font-size:12px;padding:0 6px;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.25);backdrop-filter:blur(6px)}
  /* Tools */
  .tools{position:absolute;inset:8px 8px auto auto;display:none;gap:8px;z-index:2}
  .tool{background:rgba(20,22,28,.6);border:1px solid rgba(255,255,255,.25);color:#fff;border-radius:999px;padding:6px 10px;font-size:12px;cursor:pointer}
  .tool:hover{background:rgba(20,22,28,.8)}
  /* Editing state */
  body.editing .tile img, body.editing .tile video{cursor:default}
  body.editing .tile:hover .tools{display:flex}
  .tile.selected{outline:2px solid rgba(215,194,159,.85);box-shadow:0 12px 36px rgba(215,194,159,.25)}

  /* Floating drop box */
  .drop-box{
    position:fixed;
    pointer-events:none;
    border-radius:16px;
    border:2px dashed rgba(215,194,159,.9);
    box-shadow:0 0 0 2px rgba(215,194,159,.2), 0 12px 40px rgba(0,0,0,.45);
    transition: left .08s ease, top .08s ease, width .08s ease, height .08s ease, opacity .12s ease;
    opacity:0;
    z-index:150;
  }
  .drop-box.show{opacity:1}

  /* Lightbox */
  .lightbox{--caption-space-x:0px;--caption-space-y:0px;position:fixed;inset:0;display:grid;place-items:center;background:rgba(10,12,16,.72);backdrop-filter:blur(6px);opacity:0;pointer-events:none;transition:opacity .25s ease;z-index:100;overflow:hidden}
  .lightbox.open{opacity:1;pointer-events:auto}
  .lb-shell{position:relative;display:flex;align-items:center;justify-content:center;gap:0;transform:translate(var(--shift-x,0),var(--shift-y,0));transition:transform .38s var(--resize-ease);will-change:transform}
  .media-wrap{position:relative}
  .lightbox .media{max-width:calc(min(86vw,1400px) - var(--caption-space-x));max-height:calc(86vh - var(--caption-space-y));border-radius:18px;box-shadow:0 24px 80px rgba(0,0,0,.6);display:block;transition:max-width .32s var(--resize-ease),max-height .32s var(--resize-ease),filter .18s ease;will-change:max-width,max-height}
  #lbVideo{display:none;background:#000} #lbImage{display:block}
  .lightbox.show-video #lbVideo{display:block} .lightbox.show-video #lbImage{display:none}
  .lb-btn{position:absolute;top:50%;transform:translateY(-50%);background:rgba(255,255,255,.08);border:1px solid #ffffff;color:#ffffff;box-shadow:0 18px 40px rgba(0,0,0,.45);border-radius:999px;width:42px;height:42px;display:grid;place-items:center;cursor:pointer;z-index:5}
  .lb-prev{left:24px;} 
  .lb-next{right:24px;} 
  .lb-close{top:24px;right:24px;transform:none;width:40px;height:40px;}

  .controls{position:absolute;left:50%;bottom:var(--ctrl-bottom);transform:translateX(-50%) scale(var(--ctrl-scale));transform-origin:50% 100%;display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:999px;background:rgba(0,0,0,.45);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.25);opacity:0;pointer-events:none;transition:opacity .25s ease;z-index:6;will-change:transform,bottom}
  .lightbox:not(.show-video) .controls{display:none !important}
  .controls.show{opacity:1;pointer-events:auto}
  .cbtn{appearance:none;border:0;cursor:pointer;border-radius:999px;height:34px;min-width:34px;padding:0 10px;display:grid;place-items:center;background:rgba(255,255,255,.1);color:#fff}
  .cbtn:hover{background:rgba(255,255,255,.18)}
  .ctime{min-width:92px;text-align:center;font-variant-numeric:tabular-nums}
  .seek{width:180px} .seek input[type=range]{width:100%}
  .vol{width:90px} .vol input[type=range]{width:100%}
  .cspeed{appearance:none;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.25);color:#fff;border-radius:10px;padding:4px 8px}
  .loop.active{box-shadow:0 0 0 2px rgba(215,194,159,.6) inset}

  /* Caption panel */
  .caption-panel{position:absolute;top:0;left:100%;height:100%;width:min(28vw,380px);transform:translateX(12px);opacity:0;display:flex;flex-direction:column;gap:10px;background:linear-gradient(90deg,rgba(14,16,22,.0),rgba(14,16,22,.65));padding:18px 18px 18px 22px;transition:transform .32s var(--resize-ease),opacity .28s ease,width .2s ease,height .2s ease;border-top-right-radius:18px;border-bottom-right-radius:18px;z-index:4;pointer-events:none;overflow:auto}
  .caption-panel.visible,.caption-panel.pinned{transform:translateX(0);opacity:1;pointer-events:auto}
  .caption-head{display:flex;align-items:center;gap:10px}
  .caption-title{font-weight:700;opacity:.9;flex:1}
  .caption-meta{font-size:12px;color:var(--muted)}
  .caption-input,.caption-text{width:100%;border-radius:12px;border:1px solid var(--stroke);background:rgba(255,255,255,.06);color:#fff;padding:10px 12px;backdrop-filter:blur(6px);box-shadow:inset 0 0 0 1px rgba(255,255,255,.04);transition:border-color .2s ease,box-shadow .2s ease,background .2s ease,height .2s var(--resize-ease)}
  .caption-input::placeholder,.caption-text::placeholder{color:var(--muted)}
  .caption-input:focus,.caption-text:focus{outline:none;color:#fff;border-color:rgba(215,194,159,.5);box-shadow:0 0 0 2px rgba(215,194,159,.25);background:rgba(255,255,255,.08)}
  .caption-input{height:40px;line-height:20px}
  .caption-text{resize:vertical;min-height:110px;max-height:50vh;overflow:auto}
  .caption-save{align-self:flex-start}
  .pin{appearance:none;border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,.08);color:#fff;border-radius:999px;padding:6px 10px;cursor:pointer}
  .pin.active{background:rgba(215,194,159,.22);border-color:rgba(215,194,159,.6)}

  .caption-handle{position:absolute;top:50%;right:0;transform:translate(100%,-50%);width:2px;height:60%;background:linear-gradient(180deg,rgba(215,194,159,.0),rgba(215,194,159,.85),rgba(215,194,159,.0));border-radius:2px;z-index:6;opacity:.6;pointer-events:none}
  .caption-hit{position:absolute;left:var(--hit-left,0px);top:var(--hit-top,0px);height:var(--hit-height,0px);width:var(--hit-width,40px);z-index:3;pointer-events:auto;background:transparent}

  .lightbox.mode-bottom .caption-panel{top:100%;left:0;width:100%;height:auto;transform:translateY(12px);padding:14px 18px 18px;background:linear-gradient(180deg,rgba(14,16,22,.0),rgba(14,16,22,.65));border-top-right-radius:0;border-bottom-right-radius:18px;border-bottom-left-radius:18px;border-top-left-radius:0}
  .lightbox.mode-bottom .caption-panel.visible,.lightbox.mode-bottom .caption-panel.pinned{transform:translateY(0)}
  .lightbox.mode-bottom .caption-handle{top:auto;right:auto;bottom:0;left:50%;width:60%;height:2px;transform:translate(-50%,100%);background:linear-gradient(90deg,rgba(215,194,159,.0),rgba(215,194,159,.85),rgba(215,194,159,.0))}

  .drop-overlay{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.35);z-index:200}
  .drop-overlay.show{display:grid}
  .drop-card{padding:18px 22px;border-radius:14px;border:1px solid var(--stroke);background:rgba(255,255,255,.06);color:#fff;text-align:center}
  .drop-card small{display:block;opacity:.7;margin-top:6px}

  /* ===== Responsive control panel layout ===== */
  :root { --dial-size: 180px; }

  .panel-controls{
    display:grid;
    gap:16px;
    align-items:center;
  }
  .controls-dial{ display:grid; justify-items:center; gap:6px; }
  .controls-actions{ display:grid; gap:10px; }

  /* Landscape (horizontal aspect ratio): stack vertically */
  @media (orientation: landscape){
    .panel-controls{ grid-template-columns: 1fr; }
    :root{ --dial-size: clamp(140px, 18vw, 200px); }
    .controls-dial{ justify-self:center; }
  }

  /* Portrait (vertical aspect ratio): dial left, actions right */
  @media (orientation: portrait){
    .panel-controls{ grid-template-columns: minmax(180px, 38%) 1fr; align-items:start; }
    :root{ --dial-size: clamp(160px, 26vh, 240px); }
    .controls-dial{ align-self:start; }
  }

  /* Tidy rows inside actions column */
  .controls-actions .row{
    display:grid;
    grid-template-columns: 120px 1fr;
    align-items:center;
    gap:12px;
    padding:4px 0;
    text-align:left;
  }


  /* === Lightbox chrome: contrast + auto-hide on media hover === */
  .lb-btn{
    background: linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,.35));
    border: 1.6px solid rgba(255,255,255,.92);
    color:#fff;
    backdrop-filter: blur(4px);
    box-shadow: 0 18px 40px rgba(0,0,0,.5);
    filter: drop-shadow(0 4px 12px rgba(0,0,0,.45));
    text-shadow: 0 1px 6px rgba(0,0,0,.65), 0 0 0.5px rgba(255,255,255,.35);
  }
  .lb-btn.ah{ opacity:0; pointer-events:none; transition:opacity .18s ease; }
  /* Show only when cursor is over the media area */
  .lightbox.media-hover .lb-btn.ah{ opacity:1; pointer-events:auto; }


  /* Show when media or chrome are hovered */
  .lightbox.media-hover .lb-btn.ah,
  .lightbox.ui-on .lb-btn.ah{ opacity:1; pointer-events:auto; }


  body.editing .seq-badge{ display:grid; }


  /* === Layout presets popover & grid variants === */
  .menu-popover{
    position: fixed;
    z-index: 99999;
    min-width: 260px;
    max-width: 360px;
    padding: 12px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.15);
    background: rgba(20,22,28,.94);
    color:#fff;
    backdrop-filter: blur(10px);
    box-shadow: 0 22px 60px rgba(0,0,0,.55);
    pointer-events: auto;
  }
  .menu-popover[hidden]{ display:none !important; }
  .menu-popover .row{ display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 8px 0; }
  .menu-popover h3{ margin: 4px 0 6px; font-size: 12px; letter-spacing: .08em; opacity:.8; text-transform: uppercase; }
  .menu-popover button{
    padding:8px 10px; border-radius: 10px; border:1px solid rgba(255,255,255,.2);
    background: rgba(255,255,255,.06); color:#fff; cursor:pointer;
  }
  .menu-popover button:hover{ background: rgba(255,255,255,.12); }
  .grid.cols-2{ grid-template-columns: repeat(2, 1fr) !important; }
  .grid.cols-3{ grid-template-columns: repeat(3, 1fr) !important; }
  .grid.cols-4{ grid-template-columns: repeat(4, 1fr) !important; }
  .grid.filmstrip{
    grid-auto-flow: column;
    grid-template-columns: none !important;
    grid-auto-columns: minmax(280px, 1fr);
    overflow: auto;
  }


  /* === Tile Edit: context menu + editor modal === */
  .tile-ctx {
    position: fixed; z-index: 100000;
    min-width: 160px; padding: 8px;
    border-radius: 10px; border:1px solid rgba(255,255,255,.16);
    background: rgba(20,22,28,.96); color:#fff;
    box-shadow: 0 20px 60px rgba(0,0,0,.55);
    backdrop-filter: blur(8px);
  }
  .tile-ctx[hidden]{ display:none !important; }
  .tile-ctx button {
    width:100%; text-align:left; padding:8px 10px;
    border-radius:8px; border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.06); color:#fff; cursor:pointer;
  }
  .tile-ctx button:hover{ background:rgba(255,255,255,.12); }

  .editor-modal{
    position: fixed; inset:0; z-index: 100001;
    display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,.55);
  }
  .editor-modal[hidden]{ display:none !important; }
  .editor-sheet{
    display:grid; grid-template-columns: minmax(320px, 66vh) 320px;
    gap:18px; padding:18px;
    border-radius:16px; border:1px solid rgba(255,255,255,.16);
    background: rgba(18,20,26,.96); color:#fff; box-shadow:0 26px 80px rgba(0,0,0,.6);
    max-width: min(92vw, 1200px);
  }
  @media (max-width: 900px){
    .editor-sheet{ grid-template-columns: 1fr; }
  }
  .edit-stage{
    position: relative; width: 100%; aspect-ratio: 1 / 1;
background: #0f1115;
    border-radius: 12px; overflow: hidden;
    border:1px solid rgba(255,255,255,.16);
    touch-action: none;
  }
  .edit-stage img{
    position:absolute; left:50%; top:50%;
    transform: translate(-50%,-50%) scale(var(--s,1));
    transform-origin: 50% 50%;
    user-select:none; -webkit-user-drag:none; pointer-events:none;
    will-change: transform;
  }
  /* Crop bounding box (priority interaction target) */
  .crop-box{
    position:absolute; left:0; top:0; width:60%; height:60%;
    border:2px solid rgba(255,255,255,.95);
    box-shadow: 0 0 0 200vmax rgba(0,0,0,.35); /* dim outside area */
    cursor: move; z-index:2;
  }
  .crop-box .grid-lines{
    position:absolute; inset:0; pointer-events:none;
    background:
      linear-gradient(to right, rgba(255,255,255,.75) 1px, transparent 1px) 33.333% 0/33.333% 100%,
      linear-gradient(to right, rgba(255,255,255,.75) 1px, transparent 1px) 66.666% 0/33.333% 100%,
      linear-gradient(to bottom, rgba(255,255,255,.75) 1px, transparent 1px) 0 33.333%/100% 33.333%,
      linear-gradient(to bottom, rgba(255,255,255,.75) 1px, transparent 1px) 0 66.666%/100% 33.333%;
    mix-blend-mode: screen;
  }
  .handle{
    position:absolute; width:18px; height:18px; background:#fff; border-radius:3px;
    border:1px solid rgba(0,0,0,.4); box-shadow:0 2px 6px rgba(0,0,0,.4);
    z-index:3;
  }
  .handle::after{ /* generous hit-area */
    content:""; position:absolute; inset:-8px; background:transparent;
  }
  .handle.tl{ left:-9px; top:-9px; cursor:nwse-resize; }
  .handle.tr{ right:-9px; top:-9px; cursor:nesw-resize; }
  .handle.br{ right:-9px; bottom:-9px; cursor:nwse-resize; }
  .handle.bl{ left:-9px; bottom:-9px; cursor:nesw-resize; }
  .handle.t{ left:50%; top:-9px; transform:translateX(-50%); width:22px; height:12px; cursor:ns-resize; }
  .handle.b{ left:50%; bottom:-9px; transform:translateX(-50%); width:22px; height:12px; cursor:ns-resize; }
  .handle.l{ left:-9px; top:50%; transform:translateY(-50%); width:12px; height:22px; cursor:ew-resize; }
  .handle.r{ right:-9px; top:50%; transform:translateY(-50%); width:12px; height:22px; cursor:ew-resize; }

  .editor-controls{ display:grid; gap:12px; }
  .ratio-row, .ctrl-row{ display:flex; flex-wrap:wrap; gap:8px; }
  .ratio-row button, .ctrl-row button{
    padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.16);
    background:rgba(255,255,255,.06); color:#fff; cursor:pointer;
  }
  .ratio-row button.active{ background: rgba(215,194,159,.16); border-color: rgba(215,194,159,.5); }
  .ctrl-row input[type="range"]{ width:100%; }
  .editor-actions{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
  .editor-actions button{ padding:10px 12px; border-radius:999px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.06); color:#fff; cursor:pointer }
  .editor-actions button.apply{ background: rgba(48,181,99,.18); border-color: rgba(48,181,99,.5); }
  .editor-actions button.reset{ background: rgba(215,69,69,.12); border-color: rgba(215,69,69,.45); }


/* Video tiles: preserve aspect, no warping inside tiles */
.tile video{
  width:100%; height:100%;
  object-fit: contain;
  display:block;
}

/* Context menu styling (reuse glass look) */
.video-ctx {
  position: fixed; z-index: 100000;
  min-width: 160px; padding: 8px;
  border-radius: 10px; border:1px solid rgba(255,255,255,.12);
  background: rgba(20,22,28,.96); color:#fff;
  box-shadow: 0 20px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(8px);
}
.video-ctx[hidden]{ display:none !important; }
.video-ctx button{
  width:100%; text-align:left; padding:8px 10px;
  border-radius:8px; border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.06); color:#fff; cursor:pointer;
  margin-bottom:6px;
}
.video-ctx button:last-child{ margin-bottom:0; }
.video-ctx button:hover{ background:rgba(255,255,255,.12); }


.tile.fitw video, .tile[data-fit="width"] video{
  width:100%; height:auto; object-fit: initial; /* size by width; no forced contain */
  max-height:none;
}


/* Video tiles: default - preserve aspect; when AR overridden, fill both width & height */
.tile video{ width:100%; height:100%; object-fit: contain; display:block; }
.tile[data-ar-override] video{ object-fit: cover; } /* fills tile both axes without distortion (may crop) */


/* ===== Editor panel polish ===== */
.editor-sheet{ gap:18px; }
.editor-controls{
  display:flex; flex-direction:column; gap:14px;
  padding:14px 14px 16px;
  min-width: 320px; max-width: 380px;
  background: linear-gradient(180deg, rgba(18,20,26,.82), rgba(18,20,26,.66));
  border:1px solid rgba(255,255,255,.10);
  border-radius: 14px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 10px 30px rgba(0,0,0,.30);
  backdrop-filter: blur(8px);
}
.editor-controls .subhead{
  font-weight: 700;
  letter-spacing: .25px;
  font-size: 13px;
  opacity: .95;
  padding: 2px 4px 6px;
}
/* Aspect ratio row — tidy spacing and true-to-shape buttons from earlier */
.ratio-row{ --btnH: 52px; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
.ratio-row button[data-ar]{
  height: var(--btnH);
  width:  calc(var(--btnH) * var(--ar, 1));
  min-width: 32px;
  display:flex; align-items:center; justify-content:center;
  padding:0; line-height:1; font-weight:600;
  border-radius: 12px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color:#eef1f5;
  cursor:pointer;
  box-shadow: 0 8px 24px rgba(0,0,0,.28);
  transition: transform .12s ease, background .15s ease, border-color .15s ease;
}
.ratio-row button[data-ar]:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
.ratio-row button[data-ar].active{ background: rgba(104,187,106,.20); border-color: rgba(104,187,106,.45); }
.ratio-row button[data-ar="free"]{
  --ar: 1;
  background: repeating-linear-gradient(135deg, rgba(255,255,255,.10) 0 6px, rgba(255,255,255,.04) 6px 12px);
  border-style: dashed;
}

/* Slider styling — consistent track/thumb across browsers */
.ctrl-row{ display:flex; align-items:center; gap:10px; }
.ctrl-row input[type="range"]{
  width:100%; height: 8px; background: transparent; -webkit-appearance: none; appearance: none;
}
/* WebKit */
.ctrl-row input[type="range"]::-webkit-slider-runnable-track{
  height:8px; border-radius:999px;
  background: linear-gradient(90deg, rgba(64,132,255,.8), rgba(255,255,255,.35));
}
.ctrl-row input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none; appearance: none;
  width:18px; height:18px; border-radius:50%;
  background:#0f1115; border:2px solid rgba(255,255,255,.9);
  margin-top:-5px; box-shadow:0 2px 8px rgba(0,0,0,.35);
}
/* Firefox */
.ctrl-row input[type="range"]::-moz-range-track{
  height:8px; border-radius:999px;
  background: linear-gradient(90deg, rgba(64,132,255,.8), rgba(255,255,255,.35));
}
.ctrl-row input[type="range"]::-moz-range-thumb{
  width:18px; height:18px; border-radius:50%;
  background:#0f1115; border:2px solid rgba(255,255,255,.9);
  box-shadow:0 2px 8px rgba(0,0,0,.35);
}

/* Action buttons — rounded rectangles, consistent size & spacing */
.editor-actions{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; }
.editor-actions button{
  height:44px; border-radius:12px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.06);
  color:#eef1f5; font-weight:600; letter-spacing:.2px;
  box-shadow: 0 8px 24px rgba(0,0,0,.28);
  transition: transform .12s ease, background .15s ease, border-color .15s ease;
}
.editor-actions button:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
.editor-actions .reset{ background: rgba(215,69,69,.16); border-color: rgba(215,69,69,.45); }
.editor-actions .apply{ background: rgba(48,181,99,.20); border-color: rgba(48,181,99,.5); }


/* Click-through guard: when lightbox is not open, remove it from hit-testing entirely */
.lightbox:not(.open){ display: none !important; }
.lightbox.open{ display: grid; }
#captionHit{ pointer-events:auto; }
.lightbox:not(.open) #captionHit{ display:none !important; pointer-events:none !important; }


/* ===== Fold/Expand for left panel ===== */
.app, .root, body { --panel-w: 320px; --panel-w-min: 14px; --panel-pad: 14px; }
.panel{
  position: relative;
  width: var(--panel-w);
  min-width: var(--panel-w);
  transition: width .24s cubic-bezier(.22,.61,.36,1), min-width .24s cubic-bezier(.22,.61,.36,1);
  overflow: visible; /* so handle can sit on edge */
}
/* Collapsed state: content clipped; keep a slim gutter for the handle */
.panel.collapsed{
  width: var(--panel-w-min);
  min-width: var(--panel-w-min);
  padding-left: 0; padding-right: 0;
}
.panel .panel-inner{ transition: opacity .18s ease; }
.panel.collapsed .panel-inner{ opacity: 0; pointer-events: none; }

/* The fold handle: minimalistic vertical lines along Y-axis on the panel's right edge */
.panel-fold-handle{
  position: absolute;
  top: 0; right: -6px;
  width: 16px; height: 100%;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  z-index: 10;
}
.panel-fold-handle::before{
  content:"";
  display:block;
  width: 8px; height: 46px;
  background:
    linear-gradient(90deg, rgba(255,255,255,.24) 1px, transparent 1px) left 0/4px 100% repeat-x,
    linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
  box-shadow: 0 8px 20px rgba(0,0,0,.25);
  border-radius: 8px;
}
/* Ensure main layout uses two columns so stage expands when panel collapses */
.main{
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 16px;
}



/* --- Fold handle visibility & placement fix --- */
.panel{ position: relative; overflow: visible; }
.panel-fold-handle{
  position:absolute; top:0; right:0;
  width:16px; height:100%;
  cursor:pointer; z-index:100;
  display:flex; align-items:center; justify-content:center;
}
.panel-fold-handle::before{
  content:""; display:block;
  width:8px; height:72px;
  border-radius:8px;
  background:
    linear-gradient(90deg, rgba(255,255,255,.28), rgba(255,255,255,.28)) 0 0/1px 100% no-repeat,
    linear-gradient(90deg, rgba(255,255,255,.18), rgba(255,255,255,.18)) 4px 0/1px 100% no-repeat,
    linear-gradient(90deg, rgba(255,255,255,.10), rgba(255,255,255,.10)) 8px 0/1px 100% no-repeat;
  box-shadow: 0 10px 24px rgba(0,0,0,.35);
}

/* === Sidebar panel + centered content when folded === */
:root{
  --fold: 0; /* 0 open, 1 folded */
  --sidebar-now: calc(var(--panel-w-min) + (var(--panel-w) - var(--panel-w-min)) * (1 - var(--fold)));
}
/* Make left panel a fixed sidebar */
.panel{
  position: fixed; left: 0; top: 0; height: 100vh;
  width: var(--sidebar-now); min-width: var(--sidebar-now);
  transition: none !important; z-index: 50;
}
.panel .panel-inner{ opacity: calc(1 - var(--fold)); transition: opacity .18s ease; }
.panel.collapsed .panel-inner{ pointer-events: none; }
/* Content wrapper takes sidebar width as padding so it never sits under it */
.wrap{
  padding-left: var(--sidebar-now);
  transition: none !important;
  display: block;
}
/* Center the stage/grid within the viewport; it will naturally slide as padding-left shrinks */
.stage{ max-width: 1600px; margin: 0 auto; }
/* Width-only scale for subtle proportional feel during folding */
.grid{
  transform-origin: center;
  transform: scaleX(calc(0.97 + 0.03 * var(--fold)));
  will-change: transform;
}

:root { --edge-pad: 15px; }

/* keep stage full-width, but add 15px on both left/right */
.stage{
  max-width: none;
  margin: 0;
}

/* left side = sidebar width + 15px, right side = 15px */
.wrap{
  padding-top: 28px !important;
  padding-bottom: 28px !important;
  padding-left: max(28px, env(safe-area-inset-left)) !important;
  padding-right: max(28px, env(safe-area-inset-right)) !important;
}

/* ==== Minimal collapsed sidebar height ==== */

:root{
  --panel-h-min: 56px; /* collapsed height */
}

.panel{ top: 0 !important; height: 100vh !important; position: fixed; }

.panel.collapsed{
  height: var(--panel-h-min) !important;
  top: 50% !important;
  transform: translateY(-50%);        /* center just in collapsed mode */
  border-radius: 12px;
  overflow: visible;
  box-shadow: 0 10px 24px rgba(0,0,0,.25);
}
.panel:not(.collapsed){ transform: none !important; }

</style>
</head>
<body>
<div class="wrap">
<section class="panel"><div class="panel-fold-handle" title="Fold / Expand"></div>


<div class="panel-inner"><h1>Impression Controls</h1><div class="panel-controls">
<div class="controls-dial">
<div class="dial" id="dial"><div class="needle" id="needle"></div></div>
<div class="label"><span id="moodLabel">Impression • 0% (Greyscale)</span></div>
</div>
<div class="controls-actions">
<div class="row">
<label>Uploads</label>
<label class="btn" for="fileInput"><span class="dot"></span> Upload media</label>
<input accept="image/*,video/*" hidden="" id="fileInput" multiple="" type="file"/>
</div>
<div class="row">
<label>Edit</label>
<div class="chip" id="editToggle"><span class="dot"></span> Edit mode</div>
</div>
<div class="row">
<label>Playback</label>
<div class="chip" id="autoPlayToggle"><span class="dot"></span> Auto Play</div>
</div>
<div class="row">
<label>Layouts</label>
<div class="chip" id="layoutBtn"><span class="dot"></span> Layouts</div>
</div><div class="row"><label>Slide Show</label><div class="chip" id="slideshowBtn"><span class="dot"></span> Slideshow</div></div>
<div class="row">
  <label>Project</label>
  <div class="chip" id="saveBtn"><span class="dot"></span> Save</div>
</div>
<div class="row">
  <label>Load</label>
  <div class="chip" id="loadBtn"><span class="dot"></span> Load</div>
  <input id="loadInput" type="file" accept="application/json" hidden>
</div>
<div class="row">
  <label>Media Root</label>
  <div class="chip" id="linkFolderBtn"><span class="dot"></span> Link folder…</div>
</div>

</div>
</div></div></section>
<section class="stage" id="stage">
<div class="grid" id="grid">
<!-- Seed tiles -->
<div class="tile"><span class="seq-badge">0</span><div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div><img alt="" src="https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?q=80&amp;w=1200&amp;auto=format&amp;fit=crop"/></div>
<div class="tile"><span class="seq-badge">1</span><div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div><img alt="" src="https://images.unsplash.com/photo-1491553895911-0055eca6402d?q=80&amp;w=1200&amp;auto=format&amp;fit=crop"/></div>
<div class="tile"><span class="seq-badge">2</span><div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div><img alt="" src="https://images.unsplash.com/photo-1501785888041-af3ef285b470?q=80&amp;w=1200&amp;auto=format&amp;fit=crop"/></div>
<div class="tile"><span class="seq-badge">3</span><div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div><img alt="" src="https://images.unsplash.com/photo-1482192596544-9eb780fc7f66?q=80&amp;w=1200&amp;auto=format&amp;fit=crop"/></div>
<div class="tile"><span class="seq-badge">4</span><div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div><img alt="" src="https://images.unsplash.com/photo-1469474968028-56623f02e42e?q=80&amp;w=1200&amp;auto=format&amp;fit=crop"/></div>
<div class="tile"><span class="seq-badge">5</span><div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div><img alt="" src="https://images.unsplash.com/photo-1488521787991-ed7bbaae773c?q=80&amp;w=1200&amp;auto=format&amp;fit=crop"/></div>
</div>
<!-- Lightbox -->
<div aria-hidden="true" class="lightbox" id="lightbox">
<div class="lb-shell" id="lbShell">
<button aria-label="Close" class="lb-btn lb-close ah" id="lbClose">✕</button>
<button aria-label="Previous" class="lb-btn lb-prev ah" id="lbPrev">‹</button>
<div class="media-wrap" id="mediaWrap">
<img alt="Expanded media" class="media" id="lbImage"/>
<video class="media" id="lbVideo" loop="" muted="" playsinline=""></video>
<!-- Bottom-Centered Controls (video-only) -->
<div class="controls" id="controls">
<button class="cbtn" id="cPrev" title="Previous (←)">⟨</button>
<button class="cbtn" id="cBack" title="Back 5s">−5s</button>
<button class="cbtn" id="cPlay" title="Play/Pause">►</button>
<button class="cbtn" id="cFwd" title="Forward 5s">+5s</button>
<span class="ctime" id="cTime">00:00 / 00:00</span>
<div class="seek"><input id="cSeek" max="1000" min="0" type="range" value="0"/></div>
<button class="cbtn" id="cMute" title="Mute (M)">🔇</button>
<div class="vol"><input id="cVol" max="1" min="0" step="0.02" type="range" value="1"/></div>
<select class="cspeed" id="cSpeed" title="Speed">
<option>0.5×</option><option>0.75×</option><option selected="">1×</option><option>1.25×</option><option>1.5×</option><option>2×</option>
</select>
<button class="cbtn loop" id="cLoop" title="Loop">∞</button>
<button class="cbtn" id="cNext" title="Next (→)">⟩</button>
</div>
<div class="caption-handle" id="captionHandle" title="Show caption"></div>
<div class="caption-panel" id="captionPanel">
<div class="caption-head">
<div class="caption-title">Caption</div>
<button class="pin" id="captionPin" title="Pin panel">Pin</button>
</div>
<div class="caption-meta" id="captionMeta">—</div>
<input class="caption-input" id="captionTitle" placeholder="Title (optional)"/>
<textarea class="caption-text" id="captionText" placeholder="Write notes or a description..."></textarea>
<button class="btn caption-save" id="captionSave"><span class="dot"></span> Save</button>
</div>
</div>
<div aria-hidden="true" class="caption-hit" id="captionHit"></div>
<button aria-label="Next" class="lb-btn lb-next ah" id="lbNext">›</button>
</div>
</div>
</section>
</div>
<!-- Global drop overlay -->
<div class="drop-overlay" id="dropOverlay">
<div class="drop-card">
      Drop images or videos to add
      <small>Files from your computer, or image/video links</small>
</div>
</div>
<!-- Floating drop box element -->
<div aria-hidden="true" class="drop-box" id="dropBox"></div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // ===== Dial =====
  const dial = document.getElementById('dial');
  const needle = document.getElementById('needle');
  const moodLabel = document.getElementById('moodLabel');
  function setCSS(v,val){ document.documentElement.style.setProperty(v,val); }
  function applyMoodFromAngle(a){
    needle.style.setProperty('--angle', a+'deg');
    const p=(a%360)/360, gray=(1-p);
    setCSS('--gray', gray.toFixed(3));
    moodLabel.textContent = p===0 ? 'Impression • 0% (Greyscale)' : p===1 ? 'Impression • 100% (Full Color)' : `Impression • ${Math.round(p*100)}%`;
  }
  function angleFromEvent(e){
    const r=dial.getBoundingClientRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
    const p=e.touches?e.touches[0]:e;
    return (Math.atan2(p.clientY-cy,p.clientX-cx)*180/Math.PI+90+360)%360;
  }
  const dialState={dragging:false};
  dial.addEventListener('mousedown',e=>{ dialState.dragging=true; dial.classList.add('dragging'); applyMoodFromAngle(angleFromEvent(e)); e.preventDefault?.(); });
  window.addEventListener('mousemove',e=>{ if(!dialState.dragging) return; applyMoodFromAngle(angleFromEvent(e)); });
  window.addEventListener('mouseup',()=>{ dialState.dragging=false; dial.classList.remove('dragging'); });
  dial.addEventListener('touchstart',e=>{ dialState.dragging=true; dial.classList.add('dragging'); applyMoodFromAngle(angleFromEvent(e)); },{passive:true});
  window.addEventListener('touchmove',e=>{ if(!dialState.dragging) return; applyMoodFromAngle(angleFromEvent(e)); },{passive:true});
  window.addEventListener('touchend',()=>{ dialState.dragging=false; dial.classList.remove('dragging'); });
  applyMoodFromAngle(0);

  // ===== Core refs =====
  const grid   = document.getElementById('grid');
  // Prevent native image/video drag; only our drop-box should move.
  grid.addEventListener('dragstart', (e)=>{
    if (e.target && (e.target.closest && e.target.closest('.tile img, .tile video'))) {
      e.preventDefault();
    }
  });
  function markUndraggable(root){
    if(!root) return;
    const list = root.matches ? (root.matches('.tile img, .tile video') ? [root] : []) : [];
    const nodes = [...(root.querySelectorAll ? root.querySelectorAll('.tile img, .tile video') : []), ...list];
    nodes.forEach(n=>{ try{ n.draggable = false; }catch(_){} });
  }
  // Initial pass
  markUndraggable(document);
  // Observe future additions inside the grid
  const _dragGuardObserver = new MutationObserver(muts=>{
    muts.forEach(m=>{
      m.addedNodes && m.addedNodes.forEach(n=>{
        if(n.nodeType === 1) markUndraggable(n);
      });
    });
  });
  _dragGuardObserver.observe(grid, {childList:true, subtree:true});

  const stage  = document.getElementById('stage');
  const editToggle = document.getElementById('editToggle');
  const autoPlayToggle = document.getElementById('autoPlayToggle');
  const dropOverlay=document.getElementById('dropOverlay');
  const dropBox = document.getElementById('dropBox');

  // ===== Edit mode gating =====
  let editing=false;
  function setEditMode(on){
    editing=!!on;
    document.body.classList.toggle('editing',editing);
    if(!editing) clearSelection();
    dropOverlay.classList.remove('show'); dragDepth=0;
    refreshMedia();
  }
  editToggle.addEventListener('click',()=>{ editToggle.classList.toggle('active'); setEditMode(editToggle.classList.contains('active')); });

  // ===== Tile tools =====
  function bindTileTools(tile){
    tile.querySelector('.tool-del').addEventListener('click',e=>{ e.stopPropagation(); tile.remove(); refreshMedia(); updateSequenceIndices(); });
    tile.querySelector('.tool-s1').addEventListener('click',e=>{ e.stopPropagation(); tile.classList.remove('size-2','size-3'); });
    tile.querySelector('.tool-s2').addEventListener('click',e=>{ e.stopPropagation(); tile.classList.add('size-2'); tile.classList.remove('size-3'); });
    tile.querySelector('.tool-s3').addEventListener('click',e=>{ e.stopPropagation(); tile.classList.add('size-3'); tile.classList.remove('size-2'); });
  }

  // ===== Selection + drop-box reorder =====
  let selectedTile = null;
  let currentDropTarget = null;
  let dragging = false;
  let pointerId = null;

  
  let longPressTimer = null;
  const HOLD_DELAY_MS = 220;
function clearSelection(){
    if(selectedTile){ selectedTile.classList.remove('selected'); selectedTile = null; }
    hideDropBox();
    currentDropTarget = null;
    dragging=false; pointerId=null;
  }

  grid.addEventListener('click', (e)=>{
    if(!editing) return;
    const tile = e.target.closest('.tile');
    if(!tile) return;
    selectTile(tile);
  });

  function selectTile(tile){
    if(selectedTile === tile) return;
    if(selectedTile) selectedTile.classList.remove('selected');
    selectedTile = tile;
    selectedTile.classList.add('selected');
  }

  
grid.addEventListener('pointerdown', (e)=>{
    if(!editing) return;
    const tile = e.target.closest('.tile');
    if(!tile) return;
    // left-click only
    if (typeof e.button !== 'undefined' && e.button !== 0) return;

    // Select but don't start drag yet (simple clicks should not trigger drop box)
    selectTile(tile);

    // Clear any previous timer
    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }

    // Start long-press to activate drag + drop box
    longPressTimer = setTimeout(()=>{
      // Still holding?
      if (e.buttons !== undefined && (e.buttons & 1) === 0) return;

      dragging = true;
      pointerId = e.pointerId;
      e.target.setPointerCapture?.(pointerId);
      showDropBoxForTile(tile);
    }, HOLD_DELAY_MS);
});

grid.addEventListener('pointermove', (e)=>{
    if(!dragging || !editing) return;
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const hit = el ? el.closest('.tile') : null;
    if(hit && hit.parentElement === grid){
      currentDropTarget = hit;
      showDropBoxForTile(hit);
      autoScrollIfNeeded(e.clientX, e.clientY);
    }
  });

  function tileIndex(t){ return [...grid.querySelectorAll('.tile')].indexOf(t); }

  
window.addEventListener('pointercancel', (e)=>{
    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    if (dragging) { dragging = false; }
});
window.addEventListener('pointerup', (e)=>{
    
    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
if(!dragging) return;
    dragging=false;
    const target = currentDropTarget;
    if(target && selectedTile && target !== selectedTile){
      const from = tileIndex(selectedTile);
      const to   = tileIndex(target);
      if(from < 0 || to < 0) { hideDropBox(); return; }
      // Insert after when moving forward; before when moving backward
      if(from < to) grid.insertBefore(selectedTile, target.nextSibling);
      else grid.insertBefore(selectedTile, target);
      updateSequenceIndices();
    }
    hideDropBox();
  });

  function showDropBoxForTile(tile){
    const r = tile.getBoundingClientRect();
    dropBox.style.left = Math.round(r.left) + 'px';
    dropBox.style.top = Math.round(r.top) + 'px';
    dropBox.style.width = Math.round(r.width) + 'px';
    dropBox.style.height = Math.round(r.height) + 'px';
    dropBox.classList.add('show');
  }
  function hideDropBox(){
    dropBox.classList.remove('show');
  }

  function autoScrollIfNeeded(x, y){
    const sr = stage.getBoundingClientRect();
    const Z = 60, SPEED = 20;
    if(y < sr.top + Z) stage.scrollTop -= SPEED;
    else if(y > sr.bottom - Z) stage.scrollTop += SPEED;
    if(x < sr.left + Z) stage.scrollLeft -= SPEED;
    else if(x > sr.right - Z) stage.scrollLeft += SPEED;
  }

  function updateSequenceIndices(){
    const tiles = [...grid.querySelectorAll('.tile')];
    tiles.forEach((t,i)=>{
      t.dataset.seq = i;
      let b = t.querySelector('.seq-badge');
      if(!b){ b = document.createElement('span'); b.className='seq-badge'; t.appendChild(b); }
      b.textContent = i;
    });
    refreshMedia();
  }

  // ===== Lightbox & Controls =====
  const lb=document.getElementById('lightbox');
  const lbImg=document.getElementById('lbImage');
  const lbVideo=document.getElementById('lbVideo');
  const lbClose=document.getElementById('lbClose');
  const lbPrev=document.getElementById('lbPrev');
  const lbNext=document.getElementById('lbNext');
  const lbShell=document.getElementById('lbShell');
  const mediaWrap=document.getElementById('mediaWrap');
  const controls=document.getElementById('controls');

  const cPrev=document.getElementById('cPrev');
  const cNext=document.getElementById('cNext');
  const cBack=document.getElementById('cBack');
  const cFwd=document.getElementById('cFwd');
  const cPlay=document.getElementById('cPlay');
  const cTime=document.getElementById('cTime');
  const cSeek=document.getElementById('cSeek');
  const cMute=document.getElementById('cMute');
  const cVol=document.getElementById('cVol');
  const cSpeed=document.getElementById('cSpeed');
  const cLoop=document.getElementById('cLoop');

  const captionHandle=document.getElementById('captionHandle');
  const captionPanel=document.getElementById('captionPanel');
  const captionMeta=document.getElementById('captionMeta');
  const captionTitle=document.getElementById('captionTitle');
  const captionText=document.getElementById('captionText');
  const captionSave=document.getElementById('captionSave');
  const captionPin=document.getElementById('captionPin');
  const captionHit=document.getElementById('captionHit');

  function fmt(t){ if(!isFinite(t)) return '00:00'; const m=Math.floor(t/60), s=Math.floor(t%60); return String(m).padStart(2,'0')+':'+String(s).padStart(2,'0'); }
  function updateTimeUI(){
    const d=lbVideo.duration||0, ct=lbVideo.currentTime||0;
    cTime.textContent = `${fmt(ct)} / ${fmt(d)}`;
    cSeek.value = d? Math.round(ct/d*1000) : 0;
  }
  function applyCaptionFor(src, meta=''){
    // Resolve a stable key based on the media node's dataset when possible
    function stableKeyForSrc(srcUrl){
      try{
        const nodes = [...document.querySelectorAll('.tile img, .tile video')];
        const n = nodes.find(el => (el.currentSrc||el.src) === srcUrl);
        if(n){ return n.dataset.key || n.dataset.relPath || n.dataset.localName || srcUrl; }
      }catch(_){}
      return srcUrl;
    }
    const key = stableKeyForSrc(src);
    const saved = captions.get(key) || {title:'', text:''};
    captionTitle.value = saved.title;
    captionText.value  = saved.text;
    captionMeta.textContent = meta;
  }
  function saveCaptionFor(src){
    function stableKeyForSrc(srcUrl){
      try{
        const nodes = [...document.querySelectorAll('.tile img, .tile video')];
        const n = nodes.find(el => (el.currentSrc||el.src) === srcUrl);
        if(n){ return n.dataset.key || n.dataset.relPath || n.dataset.localName || srcUrl; }
      }catch(_){}
      return srcUrl;
    }
    const key = stableKeyForSrc(src);
    captions.set(key, { title: captionTitle.value.trim(), text: captionText.value.trim() });
  }

  function isPortrait(){ return window.innerHeight > window.innerWidth; }
  function setCaptionSpace(x, y){ lb.style.setProperty('--caption-space-x', (x||0) + 'px'); lb.style.setProperty('--caption-space-y', (y||0) + 'px'); }
  function updateOrientationClass(){ lb.classList.toggle('mode-bottom', isPortrait()); lb.classList.toggle('mode-right', !isPortrait()); }

  const CAP_GAP = 12;
  let rafId = 0, pendingX = 0, pendingY = 0;
  function scheduleSpaceUpdate(x, y){
    pendingX = x||0; pendingY = y||0;
    if(rafId) return;
    rafId = requestAnimationFrame(()=>{
      setCaptionSpace(pendingX, pendingY);
      applyComboShift();
      updateCaptionHitZone();
      fitControls();
      rafId = 0;
    });
  }

  function measureAndSetCaptionSpace(){
    if(!(captionPanel.classList.contains('visible') || captionPanel.classList.contains('pinned'))){
      captionPanel.style.height = isPortrait() ? 'auto' : '100%';
      scheduleSpaceUpdate(0,0); return;
    }
    if(isPortrait()){
      captionPanel.style.height = 'auto';
      const natural = Math.ceil(captionPanel.scrollHeight);
      const minH = Math.round(Math.min(Math.max(window.innerHeight * 0.22, 160), 340));
      const maxH = Math.floor(window.innerHeight * 0.86) - 24;
      const panelH = Math.max(minH, Math.min(natural, Math.max(180, maxH)));
      captionPanel.style.height = panelH + 'px';
      scheduleSpaceUpdate(0, Math.ceil(panelH + CAP_GAP));
    }else{
      const desired = Math.min(Math.max(window.innerWidth * 0.22, 220), 380);
      captionPanel.style.width = Math.round(desired) + 'px';
      const r = captionPanel.getBoundingClientRect();
      scheduleSpaceUpdate(Math.ceil(r.width + CAP_GAP), 0);
    }
  }

  function applyComboShift(){
    const hasCaption = captionPanel.classList.contains('visible') || captionPanel.classList.contains('pinned');
    let sx = 0, sy = 0;
    if(hasCaption){
      if(isPortrait()){
        sy = -Math.round((pendingY||0)/2);
      } else {
        sx = -Math.round((pendingX||0)/2);
      }
    }
    lbShell.style.setProperty('--shift-x', sx + 'px');
    lbShell.style.setProperty('--shift-y', sy + 'px');
  }

  function onResize(){ updateOrientationClass(); measureAndSetCaptionSpace(); trackDuringTransition(600); }
  window.addEventListener('resize', onResize);

  function trackDuringTransition(duration=420){
    const start = performance.now();
    function tick(now){
      updateCaptionHitZone();
      fitControls();
      if(now - start < duration) requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }

  // Lightbox media switching (order-aware)
  let idx=0, media=[], captionPinned=false;
  const captions = (window.captions instanceof Map) ? window.captions : new Map();
  window.captions = captions;
function computeMediaList(){ return [...grid.querySelectorAll('.tile img,.tile video')]; }
  function showInLightbox(node){
    updateOrientationClass();
    if(!captionPinned) captionPanel.classList.remove('visible');
    if(node.tagName.toLowerCase()==='video'){
      lb.classList.add('show-video');
      lbVideo.src=node.currentSrc||node.src; lbVideo.currentTime=0;
      lbVideo.play().catch(()=>{});
      cPlay.textContent='❚❚';
    } else {
      lb.classList.remove('show-video');
      lbImg.src=(node.dataset&&node.dataset.origSrc)?node.dataset.origSrc:(node.currentSrc||node.src);
      cPlay.textContent='►';
      controls.classList.remove('show');
    }
    const meta = node.tagName.toLowerCase()==='video'
      ? 'Video • ' + (node.videoWidth||'') + '×' + (node.videoHeight||'')
      : 'Image';
    applyCaptionFor(node.currentSrc||node.src, meta);
    captionPanel.classList.toggle('pinned', captionPinned);
    measureAndSetCaptionSpace();
    updateCaptionHitZone();
    applyComboShift();
    trackDuringTransition(600);
  }
  function openLB(i){ media = computeMediaList(); if(media[i]){ idx=i; showInLightbox(media[idx]); lb.classList.add('open'); lb.setAttribute('aria-hidden','false'); } }
  function closeLB(){ lb.classList.remove('open'); lb.setAttribute('aria-hidden','true'); lbVideo.pause(); }
  function step(d){ media = computeMediaList(); if(!media.length) return; idx=(idx+d+media.length)%media.length; showInLightbox(media[idx]); }

  document.getElementById('lbClose').addEventListener('click',closeLB);
  document.getElementById('lbPrev').addEventListener('click',()=>step(-1));
  document.getElementById('lbNext').addEventListener('click',()=>step(1));
  lb.addEventListener('click',e=>{ if(e.target===lb) closeLB(); });

  // Grid click: open lightbox only when not editing
  grid.addEventListener('click', (e)=>{
    if(editing) return;
    const el = e.target.closest('.tile img, .tile video');
    if(!el) return;
    const list = computeMediaList();
    const i = list.indexOf(el);
    if(i>-1) openLB(i);
  });

  // Keyboard shortcuts guarded
  function isTypingTarget(el){
    if(!el) return false;
    const tag = el.tagName ? el.tagName.toLowerCase() : '';
    return tag === 'input' || tag === 'textarea' || el.isContentEditable;
  }
  window.addEventListener('keydown',e=>{
    if(!lb.classList.contains('open')) return;
    if(isTypingTarget(e.target) || isTypingTarget(document.activeElement)) return;
    if(e.key==='Escape') closeLB();
    else if(e.key==='ArrowLeft') step(-1);
    else if(e.key==='ArrowRight') step(1);
    else if(e.key===' '){ e.preventDefault(); togglePlay(); }
    else if(e.key.toLowerCase()==='m'){ toggleMute(); }
  });

  // Controls
  function togglePlay(){
    if(!lb.classList.contains('show-video')) return;
    if(lbVideo.paused){ lbVideo.play(); cPlay.textContent='❚❚'; }
    else { lbVideo.pause(); cPlay.textContent='►'; }
  }
  function toggleMute(){ if(!lb.classList.contains('show-video')) return; lbVideo.muted=!lbVideo.muted; cMute.textContent = lbVideo.muted ? '🔇' : '🔈'; }
  cPlay.addEventListener('click',togglePlay);
  cBack.addEventListener('click',()=>{ if(!lb.classList.contains('show-video')) return; lbVideo.currentTime=Math.max(0,lbVideo.currentTime-5); });
  cFwd .addEventListener('click',()=>{ if(!lb.classList.contains('show-video')) return; lbVideo.currentTime=Math.min(lbVideo.duration||0,lbVideo.currentTime+5); });
  cPrev.addEventListener('click',()=>step(-1));
  cNext.addEventListener('click',()=>step(1));
  cSeek.addEventListener('input',e=>{ if(!lb.classList.contains('show-video')) return; const d=lbVideo.duration||0; lbVideo.currentTime = d*(e.target.value/1000); });
  cMute.addEventListener('click',toggleMute);
  cVol .addEventListener('input',e=>{ if(!lb.classList.contains('show-video')) return; lbVideo.volume = +e.target.value; lbVideo.muted = (lbVideo.volume===0); });
  cSpeed.addEventListener('change',e=>{ if(!lb.classList.contains('show-video')) return; lbVideo.playbackRate = parseFloat(e.target.value.replace('×','')) || 1; });
  cLoop.addEventListener('click',()=>{ if(!lb.classList.contains('show-video')) return; lbVideo.loop=!lbVideo.loop; cLoop.classList.toggle('active', lbVideo.loop); });

  lbVideo.addEventListener('timeupdate',updateTimeUI);
  lbVideo.addEventListener('loadedmetadata',()=>{ updateTimeUI(); fitControls(); });

  // Auto-hide controls
  let hideTimer=null;
  function showControls(){
    if(!lb.classList.contains('show-video')) return;
    controls.classList.add('show');
    if(hideTimer) clearTimeout(hideTimer);
    hideTimer=setTimeout(()=>controls.classList.remove('show'), 1600);
    fitControls();
  }
  function hideControls(){ controls.classList.remove('show'); if(hideTimer) clearTimeout(hideTimer); }
  mediaWrap.addEventListener('mousemove', showControls);
  mediaWrap.addEventListener('mouseenter', showControls);
  mediaWrap.addEventListener('mouseleave', hideControls);

  // Fit & position transport controls
  function fitControls(){
    if(!lb.classList.contains('show-video')) return;
    const wrap = mediaWrap.getBoundingClientRect();
    controls.style.setProperty('--ctrl-scale', 1);
    controls.style.setProperty('--ctrl-bottom', '18px');
    const naturalWidth = controls.scrollWidth;
    const naturalHeight = controls.scrollHeight;

    const margin = 24;
    const maxWidth = Math.max(80, wrap.width - margin);
    const scaleW = maxWidth / naturalWidth;

    const maxHeight = Math.max(60, wrap.height - margin);
    const scaleH = maxHeight / naturalHeight;

    let scale = Math.min(1, scaleW, scaleH);
    scale = Math.max(0.65, scale);

    const bottom = wrap.height < (naturalHeight * scale + 24) ? 6 : 18;

    controls.style.setProperty('--ctrl-scale', scale.toFixed(3));
    controls.style.setProperty('--ctrl-bottom', bottom + 'px');
  }

  // ===== Caption reveal/hide & pin =====
  let revealTimer=null, hideIntentTimer=null;

  function revealCaption(){
    if(revealTimer){ clearTimeout(revealTimer); revealTimer=null; }
    if(!captionPinned){
      revealTimer=setTimeout(()=>{
        captionPanel.classList.add('visible');
        measureAndSetCaptionSpace();
        applyComboShift();
        trackDuringTransition(480);
      },80);
    }
  }
  function concealCaption(){
    if(revealTimer){ clearTimeout(revealTimer); revealTimer=null; }
    if(!captionPinned){
      if(hideIntentTimer){ clearTimeout(hideIntentTimer); }
      hideIntentTimer=setTimeout(()=>{
        captionPanel.classList.remove('visible');
        measureAndSetCaptionSpace();
        applyComboShift();
        trackDuringTransition(420);
      },120);
    }
  }
  captionHit.addEventListener('mouseenter', revealCaption);
  captionHit.addEventListener('mouseleave', concealCaption);
  captionHandle.addEventListener('mouseenter', revealCaption);
  captionHandle.addEventListener('mouseleave', concealCaption);
  captionPanel.addEventListener('mouseenter', ()=>{ if(hideIntentTimer){ clearTimeout(hideIntentTimer); } });
  captionPanel.addEventListener('mouseleave', concealCaption);

  captionPin.addEventListener('click',()=>{
    captionPinned = !captionPinned;
    captionPin.classList.toggle('active', captionPinned);
    captionPanel.classList.toggle('pinned', captionPinned);
    if(!captionPinned){ captionPanel.classList.remove('visible'); } else { captionPanel.classList.add('visible'); }
    measureAndSetCaptionSpace();
    applyComboShift();
    trackDuringTransition(600);
  });

  captionSave.addEventListener('click',()=>{
    const node = computeMediaList()[idx];
    if(!node) return;
    const key = node.currentSrc||node.src;
    saveCaptionFor(key);
    captionSave.classList.add('chip','active');
    setTimeout(()=>captionSave.classList.remove('active'), 600);
  });

  
  // Auto-save on blur/input (debounced)
  ;(function(){
    let t = null;
    function doSave(){
      const node = computeMediaList()[idx];
      if(!node) return;
      const key = node.currentSrc||node.src;
      saveCaptionFor(key);
    }
    function debounced(){
      if(t) clearTimeout(t);
      t = setTimeout(doSave, 300);
    }
    captionTitle.addEventListener('blur', doSave);
    captionText.addEventListener('blur', doSave);
    captionTitle.addEventListener('input', debounced);
    captionText.addEventListener('input', debounced);
  })();
// ===== Uploads =====
  const fileInput=document.getElementById('fileInput');
  fileInput.addEventListener('change',e=>{ handleFiles(e.target.files); e.target.value=''; });

  function appendTile(tile){
    // Assign next sequence immediately
    const nextSeq = grid.querySelectorAll('.tile').length;
    tile.dataset.seq = nextSeq;
    let b = tile.querySelector('.seq-badge');
    if(!b){ b = document.createElement('span'); b.className='seq-badge'; tile.appendChild(b); }
    b.textContent = nextSeq;
    grid.appendChild(tile);
    bindTileTools(tile);
  }

  function addImageFromURL(url){
    const tile=document.createElement('div'); tile.className='tile';
    tile.innerHTML='<div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div>';
    const img=document.createElement('img'); img.src=url; img.alt='';
    // Infer name from URL and assign stable uid key
    const clean = (url||'').split('?')[0].split('#')[0];
    const base = clean.split('/').pop() || '';
    const uid = 'uid:' + Date.now().toString(36) + Math.random().toString(36).slice(2);
    img.dataset.srcType = clean.startsWith('blob:') ? 'local' : 'url';
    img.dataset.localName = base;
    img.dataset.relPath = base;
    img.dataset.key = uid;
    tile.dataset.key = uid;
    tile.appendChild(img); appendTile(tile);
  }
  function addVideoFromURL(url){
    const tile=document.createElement('div'); tile.className='tile';
    tile.innerHTML='<div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div>';
    const vid=document.createElement('video');
    vid.src=url; vid.muted=true; vid.loop=true; vid.playsInline=true; vid.preload='metadata';
    const clean = (url||'').split('?')[0].split('#')[0];
    const base = clean.split('/').pop() || '';
    const uid = 'uid:' + Date.now().toString(36) + Math.random().toString(36).slice(2);
    vid.dataset.srcType = clean.startsWith('blob:') ? 'local' : 'url';
    vid.dataset.localName = base;
    vid.dataset.relPath = base;
    vid.dataset.key = uid;
    tile.dataset.key = uid;
    tile.appendChild(vid); appendTile(tile);
  }
  
  function addImageFromFile(file){
    const tile=document.createElement('div'); tile.className='tile';
    tile.innerHTML='<div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div>';
    const img=document.createElement('img'); img.alt='';
    img.src = URL.createObjectURL(file);
    const uid = 'uid:' + Date.now().toString(36) + Math.random().toString(36).slice(2);
    img.dataset.srcType = 'local';
    img.dataset.localName = file.name || '';
    img.dataset.relPath = (file.webkitRelativePath || file.name || '');
    img.dataset.key = uid; tile.dataset.key = uid;
    tile.appendChild(img); appendTile(tile);
  }
  function addVideoFromFile(file){
    const tile=document.createElement('div'); tile.className='tile';
    tile.innerHTML='<div class="tools"><button class="tool tool-del" title="Remove">✕</button><button class="tool tool-s1" title="Small">S</button><button class="tool tool-s2" title="Large">L</button><button class="tool tool-s3" title="Extra Large">XL</button></div>';
    const vid=document.createElement('video'); vid.muted=true; vid.loop=true; vid.playsInline=true; vid.preload='metadata';
    vid.src = URL.createObjectURL(file);
    const uid = 'uid:' + Date.now().toString(36) + Math.random().toString(36).slice(2);
    vid.dataset.srcType = 'local';
    vid.dataset.localName = file.name || '';
    vid.dataset.relPath = (file.webkitRelativePath || file.name || '');
    vid.dataset.key = uid; tile.dataset.key = uid;
    tile.appendChild(vid); appendTile(tile);
  }
  function handleFiles(files){
  if(!files || !files.length) return;
  [...files].forEach(f=>{
    if (f.type && f.type.startsWith('image/')) {
      // Use the File so we can record true name + relative path
      addImageFromFile(f);
    } else if (f.type && f.type.startsWith('video/')) {
      addVideoFromFile(f);
    }
  });
  updateSequenceIndices(); // final authoritative refresh
  refreshMedia();
}
  function inferKindFromURL(url){
    const u = (url||'').split('?')[0].split('#')[0].toLowerCase();
    const imgExt = ['.jpg','.jpeg','.png','.gif','.webp','.avif','.bmp'];
    const vidExt = ['.mp4','.webm','.mov','.m4v','.ogg','.ogv'];
    if(imgExt.some(ext=>u.endsWith(ext))) return 'image';
    if(vidExt.some(ext=>u.endsWith(ext))) return 'video';
    return null;
  }
  function handleURLs(text){
    if(!text) return;
    const parts = text.split(/\s+/).filter(Boolean);
    parts.forEach(u=>{
      try{
        const url = new URL(u).href;
        const kind = inferKindFromURL(url);
        if(kind==='image') addImageFromURL(url);
        else if(kind==='video') addVideoFromURL(url);
      }catch(_){}
    });
    updateSequenceIndices();
    refreshMedia();
  }

  // ===== External Drag & Drop (only when NOT editing) =====
  function isFileOrUrlDrag(e){
    const dt = e.dataTransfer;
    if(!dt) return false;
    const types = Array.from(dt.types||[]);
    return types.includes('Files') || types.includes('text/uri-list') || types.includes('text/plain');
  }
  let dragDepth = 0;
  window.addEventListener('dragenter', e=>{
    if(editing) return;
    if(isFileOrUrlDrag(e)){
      dragDepth++;
      dropOverlay.classList.add('show');
      e.preventDefault();
    }
  });
  window.addEventListener('dragover', e=>{
    if(editing) return;
    if(isFileOrUrlDrag(e)){
      e.preventDefault();
    }
  });
  window.addEventListener('dragleave', e=>{
    if(editing) return;
    if(isFileOrUrlDrag(e)){
      dragDepth = Math.max(0, dragDepth - 1);
      if(dragDepth===0) dropOverlay.classList.remove('show');
    }
  });
  window.addEventListener('drop', e=>{
    if(editing) return;
    if(isFileOrUrlDrag(e)){
      e.preventDefault();
      dropOverlay.classList.remove('show');
      dragDepth = 0;
      const dt = e.dataTransfer;
      if(dt && dt.files && dt.files.length){
        handleFiles(dt.files);
      } else if(dt){
        const urlList = dt.getData('text/uri-list') || dt.getData('text/plain');
        handleURLs(urlList);
      }
    }
  });

  // ===== Caption hit zone to canvas edges =====
  function updateCaptionHitZone(){
    const lbRect = lb.getBoundingClientRect();
    const shellRect = lbShell.getBoundingClientRect();
    const mediaRect = mediaWrap.getBoundingClientRect();
    let left=0, top=0, width=0, height=0;
    if(isPortrait()){
      left   = Math.max(0, Math.round(mediaRect.left - shellRect.left));
      top    = Math.max(0, Math.round(mediaRect.bottom - shellRect.top));
      width  = Math.max(0, Math.round(mediaRect.width));
      height = Math.max(0, Math.round(lbRect.bottom - mediaRect.bottom));
    }else{
      left   = Math.max(0, Math.round(mediaRect.right - shellRect.left));
      top    = Math.max(0, Math.round(mediaRect.top - shellRect.top));
      height = Math.max(0, Math.round(mediaRect.height));
      width  = Math.max(0, Math.round(lbRect.right - mediaRect.right));
    }
    lbShell.style.setProperty('--hit-left',  left + 'px');
    lbShell.style.setProperty('--hit-top',   top + 'px');
    lbShell.style.setProperty('--hit-height',height + 'px');
    lbShell.style.setProperty('--hit-width', width + 'px');
  }

  // ===== Autoplay viewport =====
  let autoPlayEnabled = false;
  let io = null;
  autoPlayToggle.addEventListener('click', ()=>{ autoPlayEnabled = !autoPlayEnabled; updateAutoplay(); });
  function getAllVideos(){ return [...document.querySelectorAll('.tile video')]; }
  function ensureObserver(){
    if(io) io.disconnect();
    if(!autoPlayEnabled) return;
    io = new IntersectionObserver(entries=>{
      entries.forEach(({target,isIntersecting})=>{
        if(!autoPlayEnabled) { try{ target.pause(); }catch(_){ } return; }
        if(isIntersecting){ target.play().catch(()=>{}); } else { try{ target.pause(); }catch(_){} }
      });
    }, { root: stage, threshold: 0.5 });
    getAllVideos().forEach(v=>io.observe(v));
  }
  function updateAutoplay(){
    autoPlayToggle.classList.toggle('active', autoPlayEnabled);
    if(!autoPlayEnabled){ getAllVideos().forEach(v=>{ try{ v.pause(); }catch(_){ } }); }
    ensureObserver();
  }

  function refreshMedia(){
    ensureObserver();
  }

  // Init
  [...grid.querySelectorAll('.tile')].forEach(bindTileTools);
  updateSequenceIndices();
});

  // === Lightbox chrome hover manager (prevents flicker, keeps buttons clickable) ===
(function(){
  const lbEl = document.getElementById('lightbox');
  const wrapEl = document.getElementById('mediaWrap');
  if(!lbEl || !wrapEl) return;
  const btns = Array.from(lbEl.querySelectorAll('.lb-btn'));

  let hideTimer = null;
  const HIDE_DELAY = 220; // small hysteresis to avoid blinking at edges

  function showUI(){
    lbEl.classList.add('ui-on');
    if(hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
  }
  function scheduleHide(){
    if(hideTimer) clearTimeout(hideTimer);
    hideTimer = setTimeout(()=>{
      // Only hide if neither media nor any button are hovered
      const overMedia = wrapEl.matches(':hover');
      const overBtn = btns.some(b=>b.matches(':hover'));
      if(!overMedia && !overBtn){
        lbEl.classList.remove('ui-on');
      }
    }, HIDE_DELAY);
  }

  // Media hover
  wrapEl.addEventListener('mouseenter', showUI);
  wrapEl.addEventListener('mousemove', showUI);
  wrapEl.addEventListener('mouseleave', scheduleHide);

  // Buttons hover: keep visible while on them
  btns.forEach(b=>{
    b.addEventListener('mouseenter', showUI);
    b.addEventListener('mousemove', showUI);
    b.addEventListener('mouseleave', scheduleHide);
  });

  // Defensive: if the pointer moves inside the lightbox, re-check target
  lbEl.addEventListener('mousemove', e=>{
    const t = e.target;
    if (wrapEl.contains(t) || t.closest('.lb-btn')) showUI();
  });
})();
// === Layout Presets ===
document.addEventListener('DOMContentLoaded', function(){
  const gridEl = document.getElementById('grid');
  const btn = document.getElementById('layoutBtn');
  const menu = document.getElementById('layoutMenu');
  if(!gridEl || !btn || !menu) return;

  function tiles(){ return Array.from(gridEl.querySelectorAll('.tile')); }
  function clearSizes(){ tiles().forEach(t=>t.classList.remove('size-2')); }
  function clearGridClasses(){ gridEl.classList.remove('cols-2','cols-3','cols-4','filmstrip'); }

  function applyLayout(kind){
    clearGridClasses();
    if(kind === 'masonry'){
      clearSizes();
    } else if(kind === 'shuffle'){
      const arr = tiles();
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      arr.forEach(t=>gridEl.appendChild(t));
    } else if(kind === 'hero-left'){
      clearSizes();
      const arr = tiles(); if(arr[0]) arr[0].classList.add('size-2');
    } else if(kind === 'hero-right'){
      clearSizes();
      const arr = tiles(); const last = arr[arr.length-1]; if(last) last.classList.add('size-2');
    } else if(kind === 'twin-heroes'){
      clearSizes();
      const arr = tiles(); if(arr[0]) arr[0].classList.add('size-2'); if(arr[1]) arr[1].classList.add('size-2');
    } else if(kind === 'checker'){
      clearSizes();
      tiles().forEach((t,i)=>{ if(i % 5 === 0) t.classList.add('size-2'); });
    } else if(kind === 'cols-2'){
      gridEl.classList.add('cols-2'); clearSizes();
    } else if(kind === 'cols-3'){
      gridEl.classList.add('cols-3'); clearSizes();
    } else if(kind === 'cols-4'){
      gridEl.classList.add('cols-4'); clearSizes();
    } else if(kind === 'filmstrip'){
      gridEl.classList.add('filmstrip'); clearSizes();
    } else if(kind === 'reset-sizes'){
      clearSizes();
    } else if(kind === 'reset-all'){
      clearSizes(); clearGridClasses();
    }
    if (typeof updateSequenceIndices === 'function') {
      updateSequenceIndices();
    } else {
      tiles().forEach((t,i)=>{ const b=t.querySelector('.seq-badge'); if(b) b.textContent=i; });
    }
  }

  function openMenuNear(el){
    // ensure visible to measure
    menu.hidden = false; menu.style.display = 'block';
    const r = el.getBoundingClientRect();
    const mw = menu.offsetWidth || 280, mh = menu.offsetHeight || 200;
    let x = Math.min(r.left, window.innerWidth - mw - 12);
    let y = Math.min(r.bottom + 6, window.innerHeight - mh - 12);
    x = Math.max(12, x); y = Math.max(12, y);
    menu.style.left = x + 'px';
    menu.style.top  = y + 'px';
  }
  function closeMenu(){ menu.hidden = true; menu.style.display = 'none'; }

  btn.addEventListener('click', (e)=>{ e.stopPropagation(); openMenuNear(btn); });
  btn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); e.stopPropagation(); openMenuNear(btn); });
  window.addEventListener('click', (e)=>{ if(!menu.contains(e.target) && e.target !== btn) closeMenu(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeMenu(); });

  menu.addEventListener('click', (e)=>{
    const b = e.target.closest('button[data-layout]'); if(!b) return;
    applyLayout(b.getAttribute('data-layout'));
    closeMenu();
  });
});


// === Tile Edit (from scratch, thumbnails only) ===
document.addEventListener('DOMContentLoaded', function(){
  const grid = document.getElementById('grid');
  const editToggle = document.getElementById('editToggle');

  const ctxMenu = document.getElementById('tileCtx');
  const ctxEdit = document.getElementById('ctxEdit');

  const modal = document.getElementById('editorModal');
  const stage = document.getElementById('editStage');
  const editImg = document.getElementById('editImg');
  const cropBox = document.getElementById('cropBox');
  const zoomSlider = document.getElementById('zoomSlider');
  const ratioRow = document.getElementById('ratioRow');
  const btnApply = document.getElementById('editApply');
  const btnCancel = document.getElementById('editCancel');
  const btnReset = document.getElementById('editReset');

  // state
  let targetTile = null;
  let natW = 0, natH = 0;
  let zoom = 1;           // multiplicative, unbounded (we auto-extend slider)
  let logZ = 0;           // log2(zoom) for slider
  let offsetX = 0, offsetY = 0; // stage px offset of image center relative to stage center
  let box = { x:0, y:0, w:0, h:0 }; // crop box in stage px
  let boxAR = 1;          // default 1:1
  const MIN_SIDE = 30;

  function isEditing(){ return document.body.classList.contains('editing') || (editToggle && editToggle.classList.contains('active')); }

  // open context menu
  grid.addEventListener('contextmenu', (e)=>{
    if(!isEditing()) return;
    const tile = e.target.closest('.tile');
    if(!tile) return;
    if(!tile.querySelector('img')) return; // images only
    e.preventDefault(); e.stopPropagation();
    targetTile = tile;
    openCtxAt(e.clientX, e.clientY);
  });

  function openCtxAt(x,y){
    ctxMenu.hidden = false;
    const mw = ctxMenu.offsetWidth || 160, mh = ctxMenu.offsetHeight || 40;
    const lx = Math.min(x, window.innerWidth - mw - 8);
    const ly = Math.min(y, window.innerHeight - mh - 8);
    ctxMenu.style.left = Math.max(8, lx) + 'px';
    ctxMenu.style.top  = Math.max(8, ly) + 'px';
  }
  function closeCtx(){ ctxMenu.hidden = true; }
  window.addEventListener('click', (e)=>{ if(!ctxMenu.contains(e.target)) closeCtx(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeCtx(); });

  // Open editor
  ctxEdit.addEventListener('click', async ()=>{
closeCtx();
    if(!targetTile) return;
    const img = targetTile.querySelector('img');
    if(!img) return;

    if(!img.dataset.origSrc) img.dataset.origSrc = img.currentSrc || img.src;

    const safeUrl = await getSafeEditableURL(img.dataset.origSrc);
    editImg.crossOrigin = 'anonymous';
    editImg.referrerPolicy = 'no-referrer';
    editImg.src = safeUrl;
    await imgOnLoad(editImg);

    natW = editImg.naturalWidth; natH = editImg.naturalHeight;
    

    modal.hidden = false;
    await new Promise(requestAnimationFrame);
    resetEditorState();
    await new Promise(requestAnimationFrame);
    applyStage(); applyBox();
  
    // Normalize target tile image styles to avoid inherited distortions
    try{
      const timg = targetTile.querySelector('img');
      if (timg){
        timg.style.transform='';
        timg.style.objectFit='contain';
        timg.removeAttribute('width'); timg.removeAttribute('height');
        timg.style.width = '100%'; timg.style.height = '100%';
      }
    }catch(_){}
    
});

  function resetEditorState(){
// zoom baseline
    zoom = 1; logZ = 0; zoomSlider.min = -4; zoomSlider.max = 4; zoomSlider.value = '0';
    offsetX = 0; offsetY = 0;
    // default AR: 1:1 and make UI reflect it
    boxAR = 1;
    if (ratioRow) {
      ratioRow.querySelectorAll('button').forEach(x=>x.classList.remove('active'));
      const sq = ratioRow.querySelector('button[data-ar="1:1"]');
      if (sq) sq.classList.add('active');
    
}// 50% of stage area, constrained to 1:1, centered
    const r = stage.getBoundingClientRect();
    const W = r.width, H = r.height;
    const area = 0.5 * W * H;
    let side = Math.sqrt(area);
    side = Math.max(MIN_SIDE, Math.min(side, Math.min(W, H)));
    box.w = side; box.h = side;
    box.x = (W - side) / 2;
    box.y = (H - side) / 2;
    applyStage();
    applyBox();
  }

  function imgOnLoad(el){ return new Promise(res=>{ if(el.complete) res(); else el.onload = res; }); }

  // Infinite zoom helpers: zoom = 2^logZ; slider extends when reaching near edges
  function setZoomFromLog(newLogZ, anchorX=0, anchorY=0){
    const rect = stage.getBoundingClientRect();
    const CW = rect.width, CH = rect.height;
    const baseScale = Math.min(CW / natW, CH / natH); // contain fit
    const oldScale = baseScale * Math.pow(2, logZ);
    const newScale = baseScale * Math.pow(2, newLogZ);
    offsetX = offsetX + (1 - newScale/oldScale) * (anchorX - offsetX);
    offsetY = offsetY + (1 - newScale/oldScale) * (anchorY - offsetY);
    logZ = newLogZ; zoom = Math.pow(2, logZ);
    const EPS = 0.08;
    const vmax = parseFloat(zoomSlider.max); const vmin = parseFloat(zoomSlider.min);
    if(logZ > vmax - EPS) zoomSlider.max = String(vmax + 2);
    if(logZ < vmin + EPS) zoomSlider.min = String(vmin - 2);
    zoomSlider.value = String(logZ);
    applyStage();
  }
  function applyStage(){
    // Compute contain-fit base scale so the image fits the stage
    const rect = stage.getBoundingClientRect();
    const baseScale = Math.min(rect.width / natW, rect.height / natH);
    const s = baseScale * Math.pow(2, logZ); // combined scale = fit * zoom
    stage.style.setProperty('--s', s);
    // Keep translate logic tied to current offsets
    editImg.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px)) scale(${s})`;
  }

  zoomSlider.addEventListener('input', ()=>{
    const v = parseFloat(zoomSlider.value)||0;
    setZoomFromLog(v, 0, 0);
  });
  stage.addEventListener('wheel', (e)=>{
    e.preventDefault(); e.stopPropagation();
    const rect = stage.getBoundingClientRect();
    const ax = e.clientX - rect.left - rect.width/2;
    const ay = e.clientY - rect.top  - rect.height/2;
    const d = -e.deltaY * 0.0015;
    setZoomFromLog(logZ + d, ax, ay);
  }, {passive:false});

  // Stage drag => pan image (cropBox interactions have priority)
  let panning = false, panStart = null;
  stage.addEventListener('pointerdown', (e)=>{
    if(e.target.closest('#cropBox')) return;
    panning = true;
    panStart = { ex:e.clientX, ey:e.clientY, ox:offsetX, oy:offsetY };
    stage.setPointerCapture?.(e.pointerId);
  });
  stage.addEventListener('pointermove', (e)=>{
    if(!panning) return;
    const dx = e.clientX - panStart.ex;
    const dy = e.clientY - panStart.ey;
    offsetX = panStart.ox + dx;
    offsetY = panStart.oy + dy;
    applyStage();
  });
  stage.addEventListener('pointerup', ()=>{ panning=false; });
  stage.addEventListener('pointercancel', ()=>{ panning=false; });

  // Crop box drag/resize with AR lock
  function stageRect(){ return stage.getBoundingClientRect(); }
  function applyBox(){
    cropBox.style.left = box.x + 'px';
    cropBox.style.top  = box.y + 'px';
    cropBox.style.width  = box.w + 'px';
    cropBox.style.height = box.h + 'px';
  }
  function clampBox(){
    const r = stageRect();
    box.w = Math.max(MIN_SIDE, Math.min(box.w, r.width));
    box.h = Math.max(MIN_SIDE, Math.min(box.h, r.height));
    box.x = Math.max(0, Math.min(box.x, r.width  - box.w));
    box.y = Math.max(0, Math.min(box.y, r.height - box.h));
  }

  function pointerToStage(e, r){
    return { x: Math.max(0, Math.min(e.clientX - r.left, r.width)), y: Math.max(0, Math.min(e.clientY - r.top, r.height)) };
  }

  let dragMode = null, start = null, anchor = null;
  cropBox.addEventListener('pointerdown', (e)=>{
    e.stopPropagation();
    const h = e.target.closest('.handle');
    const r = stageRect();
    start = { ex:e.clientX, ey:e.clientY, box:{...box}, r };
    if(h){
      if(h.classList.contains('tl')) dragMode='tl';
      else if(h.classList.contains('tr')) dragMode='tr';
      else if(h.classList.contains('br')) dragMode='br';
      else if(h.classList.contains('bl')) dragMode='bl';
      else if(h.classList.contains('t')) dragMode='t';
      else if(h.classList.contains('r')) dragMode='r';
      else if(h.classList.contains('b')) dragMode='b';
      else if(h.classList.contains('l')) dragMode='l';
      anchor = oppositeCorner(dragMode, start.box);
    } else {
      dragMode='move';
    }
    cropBox.setPointerCapture?.(e.pointerId);
  });
  cropBox.addEventListener('pointermove', (e)=>{
    if(!dragMode) return;
    const dx = e.clientX - start.ex;
    const dy = e.clientY - start.ey;
    let nx, ny, nw, nh;
    if(dragMode==='move'){
      box.x = start.box.x + dx;
      box.y = start.box.y + dy;
      clampBox(); applyBox(); return;
    }
    const r = start.r;
    if(dragMode==='tl' || dragMode==='tr' || dragMode==='br' || dragMode==='bl'){
      const p = pointerToStage(e, r); const a = anchor;
      nx = Math.min(p.x, a.x); ny = Math.min(p.y, a.y); nw = Math.abs(p.x - a.x); nh = Math.abs(p.y - a.y);
      if(boxAR){
        if(nw/nh > boxAR){ nw = nh*boxAR; } else { nh = nw/boxAR; }
        nx = Math.min(a.x, a.x - nw); ny = Math.min(a.y, a.y - nh);
      }
    } else {
      nx = start.box.x; ny = start.box.y; nw = start.box.w; nh = start.box.h;
      if(dragMode==='l'){ nx += dx; nw -= dx; }
      if(dragMode==='r'){ nw += dx; }
      if(dragMode==='t'){ ny += dy; nh -= dy; }
      if(dragMode==='b'){ nh += dy; }
      if(boxAR){
        if(dragMode==='l' || dragMode==='r'){ nh = nw / boxAR; ny = start.box.y + (start.box.h - nh)/2; }
        else { nw = nh * boxAR; nx = start.box.x + (start.box.w - nw)/2; }
      }
    }
    const r2 = stageRect();
    nx = Math.max(0, Math.min(nx, r2.width));
    ny = Math.max(0, Math.min(ny, r2.height));
    nw = Math.max(MIN_SIDE, Math.min(nw, r2.width  - nx));
    nh = Math.max(MIN_SIDE, Math.min(nh, r2.height - ny));
    box = { x:nx, y:ny, w:nw, h:nh };
    applyBox();
  });
  cropBox.addEventListener('pointerup', ()=>{ dragMode=null; });
  cropBox.addEventListener('pointercancel', ()=>{ dragMode=null; });

  function oppositeCorner(handle, b){
    if(handle==='tl') return { x:b.x+b.w, y:b.y+b.h };
    if(handle==='tr') return { x:b.x,     y:b.y+b.h };
    if(handle==='br') return { x:b.x,     y:b.y };
    if(handle==='bl') return { x:b.x+b.w, y:b.y };
    return { x:b.x+b.w/2, y:b.y+b.h/2 };
  }

  // Aspect ratio buttons only affect crop box
  ratioRow.addEventListener('click', (e)=>{
    const b = e.target.closest('button[data-ar]'); if(!b) return;
    ratioRow.querySelectorAll('button').forEach(x=>x.classList.remove('active'));
    b.classList.add('active');
    const v = b.getAttribute('data-ar');
    if(v==='free'){ boxAR = null; }
    else {
      const parts = v.split(':');
      const a = parseFloat(parts[0]); const h = parseFloat(parts[1]);
      boxAR = a/h;
    }
    const r = stageRect();
    const cx = box.x + box.w/2, cy = box.y + box.h/2;
    let w = box.w, h = box.h;
    if(boxAR){
      if(w/h > boxAR){ w = h*boxAR; } else { h = w/boxAR; }
      w = Math.min(w, r.width); h = Math.min(h, r.height);
      let x = cx - w/2, y = cy - h/2;
      box = { x: Math.max(0, Math.min(x, r.width - w)), y: Math.max(0, Math.min(y, r.height - h)), w, h };
    }
    applyBox();
  });

  // Apply/Cancel/Reset
  btnCancel.addEventListener('click', ()=>{ modal.hidden = true; });
  btnReset.addEventListener('click', ()=>{ resetEditorState(); });

  btnApply.addEventListener('click', async ()=>{
if(!targetTile) return;
    const timg = targetTile.querySelector('img');
    if(!timg) return;
    const rect = stage.getBoundingClientRect();
    const CW = rect.width, CH = rect.height;
    const baseScale = Math.min(CW / natW, CH / natH);
    const scale = baseScale * zoom;

    const cx = natW/2 - offsetX / scale;
    const cy = natH/2 - offsetY / scale;
    const sx = cx + (box.x - CW/2) / scale;
    const sy = cy + (box.y - CH/2) / scale;
    const sw = box.w / scale;
    const sh = box.h / scale;

    const sxC = Math.max(0, Math.min(natW - sw, sx));
    const syC = Math.max(0, Math.min(natH - sh, sy));
    const swC = Math.max(1, Math.min(natW, sw));
    const shC = Math.max(1, Math.min(natH, sh));

    const canvas = document.createElement('canvas');
    // Export at the crop's native pixel size (preserve as much resolution as possible)
    const outW = Math.max(1, Math.round(swC));
    const outH = Math.max(1, Math.round(shC));
    // Safety cap to avoid extreme memory usage; does not upscale
    const MAX_OUT = 4096;
    const scaleOut = Math.min(1, MAX_OUT / Math.max(outW, outH));
    canvas.width = Math.max(1, Math.round(outW * scaleOut));
    canvas.height = Math.max(1, Math.round(outH * scaleOut));
    const ctx2d = canvas.getContext('2d');
    ctx2d.imageSmoothingEnabled = true;
    ctx2d.imageSmoothingQuality = 'high';
    try{
      ctx2d.drawImage(editImg, sxC, syC, swC, shC, 0, 0, canvas.width, canvas.height);const blob = await new Promise(res=>canvas.toBlob(res, 'image/jpeg', 0.95));
      if(blob){
        const url = URL.createObjectURL(blob);
        if(!timg.dataset.origSrc) timg.dataset.origSrc = timg.currentSrc || timg.src;
        if(timg.dataset.croppedSrc){ try{ URL.revokeObjectURL(timg.dataset.croppedSrc); }catch(_){ } }
        timg.src = url; timg.dataset.croppedSrc = url;
        // Update tile aspect-ratio to match cropped thumb
        try{ targetTile.style.aspectRatio = `${canvas.width}/${canvas.height}`; 
    // Ensure no warping: clear any width/height attrs and transforms; enforce contain
    try{
      timg.removeAttribute('width'); timg.removeAttribute('height');
      timg.style.transform = '';
      timg.style.objectFit = 'contain';
      timg.style.width = '100%'; timg.style.height = '100%';
    }catch(_){ }}catch(_){}
      }
    }catch(err){
      console.warn('Canvas blocked; skipping fallback to keep lightbox pristine.', err);
    }
    modal.hidden = true;
  

});

  // ===== Helpers =====
  async function getSafeEditableURL(srcUrl){
    if(!srcUrl) throw new Error('No source URL');
    if(srcUrl.startsWith('blob:')) return srcUrl;
    try{
      const u = new URL(srcUrl, location.href);
      if(u.origin === location.origin) return srcUrl;
    }catch(_){}
    const resp = await fetch(srcUrl, { mode:'cors', credentials:'omit', referrerPolicy:'no-referrer' });
    if(!resp.ok) throw new Error('CORS fetch failed: '+resp.status);
    const blob = await resp.blob();
    return URL.createObjectURL(blob);
  }
});


// ===== Video tile aspect ratio context menu =====
document.addEventListener('DOMContentLoaded', function(){
  const grid = document.getElementById('grid');
  const editToggle = document.getElementById('editToggle');
  const videoCtx = document.getElementById('videoCtx');
  let targetVideoTile = null;

  function isEditing(){ 
    return document.body.classList.contains('editing') 
      || (editToggle && (editToggle.classList.contains('active') || editToggle.checked));
  }

  function openVideoCtx(x,y){
    videoCtx.hidden = false;
    const mw = videoCtx.offsetWidth || 160, mh = videoCtx.offsetHeight || 120;
    const lx = Math.min(x, window.innerWidth - mw - 8);
    const ly = Math.min(y, window.innerHeight - mh - 8);
    videoCtx.style.left = Math.max(8, lx) + 'px';
    videoCtx.style.top  = Math.max(8, ly) + 'px';
  }
  function closeVideoCtx(){ videoCtx.hidden = true; targetVideoTile = null; }

  if (grid){
    grid.addEventListener('contextmenu', (e)=>{
      if(!isEditing()) return;
      const tile = e.target.closest('.tile');
      if(!tile) return;
      const vid = tile.querySelector('video');
      if(!vid) return;
      e.preventDefault(); e.stopPropagation();
      targetVideoTile = tile;
      openVideoCtx(e.clientX, e.clientY);
    });
  }

  
videoCtx.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-ar]');
    if(!btn || !targetVideoTile) return;
    const val = btn.getAttribute('data-ar'); // "reset", "1:1", "16:9", "9:16"
    if(val === 'reset'){
      // Remove any overrides and return to default contain behavior
      try{
        targetVideoTile.style.removeProperty('aspect-ratio');
        targetVideoTile.removeAttribute('data-ar-override');
        if (targetVideoTile.dataset) delete targetVideoTile.dataset.arOverride;
        targetVideoTile.classList.remove('fitw');
        targetVideoTile.removeAttribute('data-fit');
      }catch(_){}
      closeVideoCtx();
      return;
    }
    const [a,b] = val.split(':').map(Number);
    if(a>0 && b>0){
      targetVideoTile.style.aspectRatio = `${a} / ${b}`;
      targetVideoTile.dataset.arOverride = `${a}:${b}`; // triggers object-fit: cover via CSS
      targetVideoTile.classList.remove('fitw');
      targetVideoTile.removeAttribute('data-fit');
    }
    closeVideoCtx();
  });

  window.addEventListener('click', (e)=>{ if(!videoCtx.contains(e.target)) closeVideoCtx(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeVideoCtx(); });

  // Ensure lightbox uses original video source (best-effort patch if pattern present)
  const lb = document.getElementById('lightbox');
  if (lb){
    const vid = lb.querySelector('video');
    // No direct changes here; lightbox player will use media's src as-is.
    // Tile aspect-ratio only changes the CSS of the grid tile and not the video source.
  }
});



</script>
<!-- Layout presets menu -->
<div class="menu-popover" hidden="" id="layoutMenu">
<h3>Templates</h3>
<div class="row">
<button data-layout="masonry">Masonry (default)</button>
<button data-layout="shuffle">Shuffle</button>
<button data-layout="hero-left">Hero Left</button>
<button data-layout="hero-right">Hero Right</button>
<button data-layout="twin-heroes">Twin Heroes</button>
<button data-layout="checker">Checkerboard</button>
</div>
<h3>Columns</h3>
<div class="row">
<button data-layout="cols-2">2 Columns</button>
<button data-layout="cols-3">3 Columns</button>
<button data-layout="cols-4">4 Columns</button>
<button data-layout="filmstrip">Filmstrip</button>
</div>
<div class="row">
<button data-layout="reset-sizes">Reset Sizes</button>
<button data-layout="reset-all">Reset All</button>
</div>
</div><div class="menu-popover" hidden="" id="slideshowMenu"><h3>Slide Direction</h3><div class="row"><button data-ss="down">Auto Scroll Down</button><button data-ss="up">Auto Scroll Up</button><button data-ss="left">Auto Scroll Left</button>
<button data-ss="right">Auto Scroll Right</button></div><div class="row"><button data-ss="stop">Stop</button></div></div>
<!-- Tile context menu -->
<div class="tile-ctx" hidden="" id="tileCtx">
<button id="ctxEdit">Edit</button>
</div>
<!-- Editor modal -->
<div class="editor-modal" hidden="" id="editorModal">
<div class="editor-sheet">
<div class="edit-stage" id="editStage" style="--img-ar:1/1; --z:1;">
<img alt="Edit target" id="editImg"/>
<div class="crop-box" id="cropBox">
<div class="grid-lines"></div>
<div class="handle tl"></div><div class="handle tr"></div>
<div class="handle br"></div><div class="handle bl"></div>
<div class="handle t"></div><div class="handle r"></div>
<div class="handle b"></div><div class="handle l"></div>
</div>
</div>
<div class="editor-controls">
<div class="subhead">Aspect Ratio</div>
<div class="ratio-row" id="ratioRow">
<button data-ar="free">Free</button>
<button class="active" data-ar="1:1">1:1</button>
<button data-ar="3:2">3:2</button>
<button data-ar="4:3">4:3</button>
<button data-ar="16:9">16:9</button>
<button data-ar="9:16">9:16</button>
<button data-ar="4:5">4:5</button>
<button data-ar="21:9">21:9</button>
</div>
<div class="subhead">Zoom</div>
<div class="ctrl-row">
<input id="zoomSlider" max="4" min="-4" step="0.001" type="range" value="0"/>
</div>
<div class="editor-actions">
<button class="reset" id="editReset">Reset</button>
<button id="editCancel">Cancel</button>
<button class="apply" id="editApply">Apply</button>
</div>
</div>
</div>
</div>
<!-- Video Aspect Ratio context menu -->
<div class="video-ctx" hidden="" id="videoCtx">
<button data-ar="reset">Reset</button>
<button data-ar="1:1">1 : 1</button>
<button data-ar="16:9">16 : 9</button>
<button data-ar="9:16">9 : 16</button>
</div>
<script>
document.addEventListener('DOMContentLoaded', function(){
  const lb = document.getElementById('lightbox') || document.querySelector('.lightbox');
  const lbShell = document.getElementById('lbShell') || (lb && lb.querySelector('.lb-shell'));
  const captionHit = document.getElementById('captionHit') || (lb && lb.querySelector('.caption-hit, #captionHit'));
  const videoCtx = document.getElementById('videoCtx');
  const tileCtx = document.getElementById('tileCtx');
  const layoutMenu = document.getElementById('layoutMenu');

  function collapseCaptionHit(){
    if(!captionHit) return;
    const host = lbShell || lb || document.documentElement;
    try{ host.style.setProperty('--hit-left','0px'); }catch(_){}
    try{ host.style.setProperty('--hit-top','0px'); }catch(_){}
    try{ host.style.setProperty('--hit-width','0px'); }catch(_){}
    try{ host.style.setProperty('--hit-height','0px'); }catch(_){}
    try{ captionHit.style.width='0px'; captionHit.style.height='0px'; }catch(_){}
  }

  function safeCloseLB(){
    if(!lb) return;
    lb.classList.remove('open');
    lb.setAttribute('aria-hidden','true');
    // Pause video if present
    try{ const v = lb.querySelector('video'); if(v) v.pause(); }catch(_){}
    // Hide stray overlays/menus
    try{ collapseCaptionHit(); }catch(_){}
    try{ if(videoCtx){ videoCtx.hidden = true; } }catch(_){}
    try{ if(tileCtx){ tileCtx.hidden = true; } }catch(_){}
    try{ if(layoutMenu){ layoutMenu.hidden = true; layoutMenu.style.display='none'; } }catch(_){}
  }

  // Close button
  try{
    const closeBtn = lb && (lb.querySelector('.lb-close') || lb.querySelector('[data-close]'));
    if(closeBtn){
      closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); safeCloseLB(); }, {capture:true});
    }
  }catch(_){}
  // Backdrop
  try{ if(lb){ lb.addEventListener('click', (e)=>{ if(e.target === lb){ safeCloseLB(); } }); } }catch(_){}
  // ESC
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ safeCloseLB(); } });

  // Guard any existing closeLB()
  try{
    const oldClose = window.closeLB;
    if(typeof oldClose === 'function'){
      window.closeLB = function(){ try{ oldClose(); }catch(_){ } safeCloseLB(); };
    }
  }catch(_){}

  // Guard updateCaptionHitZone when LB closed
  try{
    const oldUpd = window.updateCaptionHitZone;
    if(typeof oldUpd === 'function'){
      window.updateCaptionHitZone = function(){
        if(!lb || !lb.classList.contains('open')){ collapseCaptionHit(); return; }
        return oldUpd();
      };
    }
  }catch(_){}
});
</script>
<script>
  // --- Activate caption hit zone when the lightbox opens ---
  (function ensureCaptionHitActivation(){
    const lb        = document.getElementById('lightbox') || document.querySelector('.lightbox');
    const lbShell   = document.getElementById('lbShell')  || (lb && lb.querySelector('.lb-shell'));
    const captionHit= document.getElementById('captionHit') || (lb && lb.querySelector('#captionHit,.caption-hit'));
  
    if(!lb || !captionHit) return;
  
    function settleCaptionLayout(){
      // turn the hit zone back on
      try{
        captionHit.hidden = false;
        captionHit.style.display = '';
        captionHit.style.pointerEvents = 'auto';
      }catch(_){}
  
      // recompute geometry (these are your existing functions)
      try{ measureAndSetCaptionSpace && measureAndSetCaptionSpace(); }catch(_){}
      try{ updateCaptionHitZone && updateCaptionHitZone(); }catch(_){}
      try{ applyComboShift && applyComboShift(); }catch(_){}
      try{ fitControls && fitControls(); }catch(_){}
    }
  
    // 1) Wrap openLB so every open re-activates and settles layout
    try{
      const oldOpen = window.openLB;
      if (typeof oldOpen === 'function'){
        window.openLB = function(){
          const out = oldOpen.apply(this, arguments);
          // let the class toggle/layout paint first
          requestAnimationFrame(settleCaptionLayout);
          return out;
        };
      }
    }catch(_){}
  
    // 2) Watch for the 'open' class being added (covers non-openLB paths)
    try{
      const mo = new MutationObserver(muts=>{
        if (lb.classList.contains('open')){
          requestAnimationFrame(settleCaptionLayout);
        }
      });
      mo.observe(lb, { attributes: true, attributeFilter: ['class'] });
    }catch(_){}
  
    // 3) Re-settle after media becomes ready (image load / video metadata)
    // Use capture so we catch events dispatched inside the lightbox subtree
    lb.addEventListener('load',          ()=> settleCaptionLayout(), true);
    lb.addEventListener('loadeddata',    ()=> settleCaptionLayout(), true);
    lb.addEventListener('loadedmetadata',()=> settleCaptionLayout(), true);
  
    // 4) Also re-settle on resize (orientation / caption size changes)
    window.addEventListener('resize', ()=> lb.classList.contains('open') && settleCaptionLayout());
  })();
  </script>
<script>
// === Slideshow (auto-scroll) ===
(function(){
  const stage = document.getElementById('stage');
  const gridEl = document.getElementById('grid');
  const lb = document.getElementById('lightbox');
  const editToggle = document.getElementById('editToggle');
  const ssBtn = document.getElementById('slideshowBtn');
  const ssMenu = document.getElementById('slideshowMenu');

  if(!stage || !gridEl || !ssBtn || !ssMenu) return;

  function openMenuNear(el){
    ssMenu.hidden = false; ssMenu.style.display = 'block';
    const r = el.getBoundingClientRect();
    const mw = ssMenu.offsetWidth || 260, mh = ssMenu.offsetHeight || 160;
    let x = Math.min(r.left, window.innerWidth - mw - 12);
    let y = Math.min(r.bottom + 6, window.innerHeight - mh - 12);
    x = Math.max(12, x); y = Math.max(12, y);
    ssMenu.style.left = x + 'px';
    ssMenu.style.top  = y + 'px';
  }
  function closeMenu(){ ssMenu.hidden = true; ssMenu.style.display = 'none'; }
  ssBtn.addEventListener('click', (e)=>{ e.stopPropagation(); openMenuNear(ssBtn); });
  ssBtn.addEventListener('contextmenu', (e)=>{ e.preventDefault(); e.stopPropagation(); openMenuNear(ssBtn); });
  window.addEventListener('click', (e)=>{ if(!ssMenu.contains(e.target) && e.target !== ssBtn) closeMenu(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeMenu(); });

  const state = { mode:null, raf:0, last:0, speed:70, accX:0, accY:0 };

  function isEditing(){
    return document.body.classList.contains('editing') || (editToggle && (editToggle.classList.contains('active') || editToggle.checked));
  }
  function stopLoop(){
    if(state.raf){ cancelAnimationFrame(state.raf); state.raf = 0; }
    state.mode = null; state.last = 0;
    ssBtn.classList.remove('active');
  }

  function horizTarget(){
    // Use grid element when it's in filmstrip mode; else use stage
    return gridEl.classList.contains('filmstrip') ? gridEl : stage;
  }

  function step(ts){
    if(!state.mode){ state.raf = 0; return; }
    if(state.last === 0) state.last = ts;
    let dt = (ts - state.last) / 1000;
    if(dt > 0.05) dt = 0.05;
    if(dt < 0) dt = 0;
    state.last = ts;

    if(isEditing() || (lb && lb.classList.contains('open'))){ stopLoop(); return; }

    const d = state.speed * dt;

    // Vertical scroll always on stage
    const maxY = Math.max(0, stage.scrollHeight - stage.clientHeight);
    if(state.mode === 'down'){
      state.accY = (state.accY + d) % (maxY || 1);
      stage.scrollTop = state.accY;
    } else if(state.mode === 'up'){
      state.accY = (state.accY - d);
      if(maxY > 0){
        while(state.accY < 0) state.accY += maxY;
        stage.scrollTop = state.accY;
      } else {
        stage.scrollTop = 0;
      }
    } else if(state.mode === 'left'){
      // Horizontal scroll: pick correct container (grid in filmstrip mode)
      const target = horizTarget();
      const maxX = Math.max(0, target.scrollWidth - target.clientWidth);
      state.accX = (state.accX - d);
      if(maxX > 0){
        while(state.accX < 0) state.accX += maxX;
        target.scrollLeft = state.accX;
      } else {
        target.scrollLeft = 0;
      }
    } else if(state.mode === 'right'){
      const target = horizTarget();
      const maxX = Math.max(0, target.scrollWidth - target.clientWidth);
      state.accX = (state.accX + d);
      if(maxX > 0){
        state.accX = state.accX % maxX;
        target.scrollLeft = state.accX;
      } else {
        target.scrollLeft = 0;
      }
    }

    state.raf = requestAnimationFrame(step);
  }

  function start(mode){
    state.mode = mode; state.last = 0;
    // Initialize accumulators from current scroll
    state.accX = horizTarget().scrollLeft;
    state.accY = stage.scrollTop;
    ssBtn.classList.add('active');
    if(state.raf) cancelAnimationFrame(state.raf);
    try{ stage.style.scrollBehavior = 'auto'; horizTarget().style.scrollBehavior = 'auto'; }catch(_){}
    state.raf = requestAnimationFrame(step);
  }

  ssMenu.addEventListener('click', (e)=>{
    const b = e.target.closest('button[data-ss]'); if(!b) return;
    const mode = b.getAttribute('data-ss'); closeMenu();
    if(mode === 'stop'){ stopLoop(); return; }
    start(mode);
  });

  // Stop on user interaction or resize
  ['wheel','pointerdown','keydown','touchstart'].forEach(evt=>{
    stage.addEventListener(evt, ()=>{ if(state.mode) stopLoop(); }, { passive:true });
    gridEl.addEventListener(evt, ()=>{ if(state.mode) stopLoop(); }, { passive:true });
  });
  window.addEventListener('resize', ()=>{ if(state.mode) stopLoop(); });
})();</script>
<script>
// Fold/Expand left panel via minimalistic handle
document.addEventListener('DOMContentLoaded', function(){
  const panel = document.querySelector('.panel');
  if(!panel) return;
  const handle = panel.querySelector('.panel-fold-handle');
  if(!handle) return;

  // Restore last state
  try{
    const saved = localStorage.getItem('panel.collapsed');
    if(saved === '1'){ panel.classList.add('collapsed'); }
  }catch(_){}

  function togglePanel(){
    panel.classList.toggle('collapsed');
    try{ localStorage.setItem('panel.collapsed', panel.classList.contains('collapsed') ? '1':'0'); }catch(_){}
    // Refresh layout-dependent logic after transition
    setTimeout(()=>{
      try{
        if(typeof updateCaptionHitZone === 'function') updateCaptionHitZone();
        if(typeof fitControls === 'function') fitControls();
      }catch(_){}
    }, 280);
  }

  handle.addEventListener('click', (e)=>{ e.preventDefault(); togglePanel(); });
  handle.tabIndex = 0;
  handle.setAttribute('role','button');
  handle.setAttribute('aria-label','Fold or expand controls panel');
  handle.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); togglePanel(); }
  });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  const root = document.documentElement;
  const panel = document.querySelector('.panel');
  if(!panel) return;
  let handle = panel.querySelector('.panel-fold-handle');
  if(!handle) return;

  // Remove old listeners by cloning handle
  const fresh = handle.cloneNode(true);
  handle.parentNode.replaceChild(fresh, handle);
  handle = fresh;

  // Restore state
  try{
    const saved = localStorage.getItem('panel.collapsed');
    if(saved === '1'){ root.style.setProperty('--fold','1'); panel.classList.add('collapsed'); }
    else { root.style.setProperty('--fold','0'); panel.classList.remove('collapsed'); }
  }catch(_){}

  let raf = 0;
  const DURATION = 800; // ms
  const easeOutQuint = t => 1 - Math.pow(1 - t, 5);

  function animateFold(toCollapsed){
    if(raf) cancelAnimationFrame(raf);
    const start = parseFloat(getComputedStyle(root).getPropertyValue('--fold')) || 0;
    const end = toCollapsed ? 1 : 0;
    const t0 = performance.now();
    function frame(now){
      const p = Math.min(1, (now - t0)/DURATION);
      const e = easeOutQuint(p);
      const val = start + (end - start) * e;
      root.style.setProperty('--fold', val.toFixed(4));
      if(p < 1){
        raf = requestAnimationFrame(frame);
      }else{
        root.style.setProperty('--fold', String(end));
        panel.classList.toggle('collapsed', end === 1);
        try{ localStorage.setItem('panel.collapsed', end === 1 ? '1' : '0'); }catch(_){}
        // Refresh layout after settle
        try{ if(typeof updateCaptionHitZone === 'function') updateCaptionHitZone(); }catch(_){}
        try{ if(typeof fitControls === 'function') fitControls(); }catch(_){}
        raf = 0;
      }
    }
    raf = requestAnimationFrame(frame);
  }

  function togglePanel(){
    const curr = parseFloat(getComputedStyle(root).getPropertyValue('--fold')) || 0;
    animateFold(!(curr > 0.5));
  }

  handle.addEventListener('click', e => { e.preventDefault(); togglePanel(); });
  handle.tabIndex = 0;
  handle.setAttribute('role','button');
  handle.setAttribute('aria-label','Fold or expand controls panel');
  handle.addEventListener('keydown', e => {
    if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); togglePanel(); }
  });

  // Re-apply layout measurers on resize
  let tick = 0;
  window.addEventListener('resize', ()=>{
    if(tick) cancelAnimationFrame(tick);
    tick = requestAnimationFrame(()=>{
      try{ if(typeof updateCaptionHitZone === 'function') updateCaptionHitZone(); }catch(_){}
      try{ if(typeof fitControls === 'function') fitControls(); }catch(_){}
    });
  });
});
</script>


<script>
// ===== Robust Save / Load + Local Folder + Layout + Video Thumbs + Caption Hit Zone =====
document.addEventListener('DOMContentLoaded', function(){
  const grid = document.querySelector('.grid') || document.getElementById('grid');
  let captions = (window.captions instanceof Map) ? window.captions : new Map();
  window.captions = captions;

  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');
  const loadInput = document.getElementById('loadInput');
  const linkFolderBtn = document.getElementById('linkFolderBtn');

  window.mediaRootHandle = window.mediaRootHandle || null;
  window.pendingImportData = null;
  window.currentLayoutKind = window.currentLayoutKind || 'masonry';

  function readCSSVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  // grid variant helpers (cols/filmstrip)
  function gridVariant(){
    if (!grid) return 'auto';
    const cls = grid.classList;
    if (cls.contains('filmstrip')) return 'filmstrip';
    if (cls.contains('cols-4')) return 'cols-4';
    if (cls.contains('cols-3')) return 'cols-3';
    if (cls.contains('cols-2')) return 'cols-2';
    return 'auto';
  }
  function setGridVariant(v){
    if (!grid) return;
    grid.classList.remove('cols-2','cols-3','cols-4','filmstrip');
    if (v && v !== 'auto') grid.classList.add(v);
  }

  // hook into existing applyLayout(kind) if present, record currentLayoutKind
  if (typeof window.applyLayout === 'function'){
    const origApply = window.applyLayout;
    window.applyLayout = function(kind){
      window.currentLayoutKind = kind || 'masonry';
      return origApply(kind);
    }
  }

  // Delegated context menu for aspect ratio on videos (fallback)
  grid?.addEventListener('contextmenu', (e)=>{
    const vid = e.target && e.target.closest ? e.target.closest('video') : null;
    if (!vid) return;
    if (typeof window.showAspectMenu === 'function'){
      e.preventDefault();
      window.showAspectMenu(vid, e.clientX, e.clientY);
    }
  });

  // Ensure caption functions use a stable key (relPath -> localName -> data-key -> src)
  (function(){
    try{
      const origApply = window.applyCaptionFor;
      const origSave  = window.saveCaptionFor;
      function stableKeyForSrc(src){
        try{
          const nodes = [...document.querySelectorAll('.tile img, .tile video')];
          const n = nodes.find(el => (el.currentSrc||el.src) === src);
          if (n){ return n.dataset.relPath || n.dataset.localName || n.dataset.key || src; }
        }catch(_){}
        return src;
      }
      window.applyCaptionFor = function(src, meta=''){
        const key = stableKeyForSrc(src);
        const saved = captions.get(key) || {title:'', text:''};
        const titleEl = document.getElementById('captionTitle') || window.captionTitle;
        const textEl = document.getElementById('captionText') || window.captionText;
        const metaEl = document.getElementById('captionMeta') || window.captionMeta;
        if (titleEl) titleEl.value = saved.title || '';
        if (textEl) textEl.value = saved.text || '';
        if (metaEl) metaEl.textContent = meta || '';
      };
      window.saveCaptionFor = function(src){
        const key = stableKeyForSrc(src);
        const titleEl = document.getElementById('captionTitle') || window.captionTitle;
        const textEl = document.getElementById('captionText') || window.captionText;
        captions.set(key,{ title: (titleEl?.value||'').trim(), text: (textEl?.value||'').trim() });
      };
    }catch(err){ console.warn('Caption stabilizer failed:', err); }
  })();

  // Caption hit zone refresher when lightbox opens (using MutationObserver on class change)
  (function(){
    const lb = document.getElementById('lightbox');
    if (!lb) return;
    const obs = new MutationObserver(()=>{
      const open = lb.classList.contains('open') || lb.style.display === 'block';
      if (open){
        // Refresh any geometry/pointer-events the caption sidebar relies on
        const handle = lb.querySelector('.caption-handle');
        const panel = lb.querySelector('.caption-panel, .caption');
        if (handle){ handle.style.pointerEvents = 'auto'; handle.style.zIndex = 1001; }
        if (panel){ panel.style.pointerEvents = 'auto'; panel.style.zIndex = 1000; }
      }
    });
    obs.observe(lb, { attributes:true, attributeFilter:['class','style'] });
  })();

  // Helpers
  function tiles(){ return Array.from(grid?.querySelectorAll('.tile') || []); }
  function ensureTools(tile){
    if (!tile.querySelector('.tools')){
      tile.insertAdjacentHTML('afterbegin', `
        <span class="seq-badge"></span>
        <div class="tools">
          <button class="tool tool-del" title="Remove">✕</button>
          <button class="tool tool-s1" title="Small">S</button>
          <button class="tool tool-s2" title="Large">L</button>
          <button class="tool tool-s3" title="Extra Large">XL</button>
        </div>
      `);
    }
  }
  function updateSeqBadges(){
    tiles().forEach((t,i)=>{ const b=t.querySelector('.seq-badge'); if(b) b.textContent=i; });
  }

  // Serialize board
  function serializeTiles(){
    const out = [];
    tiles().forEach((t, i)=>{
      const el = t.querySelector('img,video'); if(!el) return;
      const isVideo = el.tagName.toLowerCase()==='video';
      const src = (el.dataset && el.dataset.origSrc) ? el.dataset.origSrc : (el.currentSrc || el.src);
      const key = (el.dataset && (el.dataset.key || el.dataset.relPath)) ? (el.dataset.key || el.dataset.relPath) : src;
      const cap = (typeof captions !== 'undefined' && captions instanceof Map) ? (captions.get(key) || {title:'', text:''}) : {title:'', text:''};
      const srcType = (el.dataset && el.dataset.srcType) ? el.dataset.srcType : (src && src.startsWith('blob:') ? 'local' : 'url');
      const localName = el.dataset?.localName || '';
      const relPath = el.dataset?.relPath || localName;
      const tileAR = t.style?.aspectRatio || '';
      const arOverride = t.dataset?.arOverride || '';
      const fit = t.dataset?.fit || (t.classList.contains('fitw') ? 'fitw' : (el.style?.objectFit || ''));
      const thumbTime = el.dataset?.thumbTime ? Number(el.dataset.thumbTime) : (isVideo ? 0.05 : 0);
      let size = 'normal'; if (t.classList.contains('size-3')) size='size-3'; else if (t.classList.contains('size-2')) size='size-2';
      out.push({  seq:i, kind:isVideo?'video':'image', src, size, srcType, localName, relPath, key, tileAR, arOverride, fit, thumbTime , title: cap.title || '', description: cap.text || '' });
    });
    return out;
  }
  function exportBoardData(){
    return {
      version: '1.2',
      savedAt: new Date().toISOString(),
      layout: {
        template: window.currentLayoutKind || 'masonry',
        gridVariant: gridVariant(),
        gray: readCSSVar('--gray') || '1',
        blur: readCSSVar('--blur') || '0px'
      },
      tiles: serializeTiles(),
      captions: Object.fromEntries(captions)
    };
  }

  function downloadJSON(filename, dataObj){
    const blob = new Blob([JSON.stringify(dataObj, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  // Save
  saveBtn?.addEventListener('click', ()=>{
    downloadJSON('media-board.json', exportBoardData());
    saveBtn.classList.add('active'); setTimeout(()=>saveBtn.classList.remove('active'), 600);
  });

  // Link folder (user gesture)
  linkFolderBtn?.addEventListener('click', async ()=>{
    if (!('showDirectoryPicker' in window)) { alert('This browser does not support folder access.'); return; }
    try{
      window.mediaRootHandle = await window.showDirectoryPicker({ id: 'media-root', mode: 'read' });
      linkFolderBtn.classList.add('active'); setTimeout(()=>linkFolderBtn.classList.remove('active'), 600);
      if (window.pendingImportData){ const data = window.pendingImportData; window.pendingImportData = null; await importBoardData(data); }
    }catch(err){ console.warn('Folder not chosen', err); }
  });

  // Load
  loadBtn?.addEventListener('click', ()=> loadInput?.click());
  loadInput?.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0]; e.target.value = ''; if(!file) return;
    try{
      const data = JSON.parse(await file.text());
      const needsLocal = Array.isArray(data.tiles) && data.tiles.some(t => (t.srcType||'')==='local');
      if (needsLocal && !window.mediaRootHandle){
        window.pendingImportData = data;
        alert('This project references local files. Click "Link folder…" in the sidebar to select your media root, then the import will continue.');
      } else {
        await importBoardData(data);
        loadBtn.classList.add('active'); setTimeout(()=>loadBtn.classList.remove('active'), 600);
      }
    }catch(err){
      console.error('Load failed:', err);
      alert('Failed to load project. Is this a valid JSON export?');
    }
  });

  async function importBoardData(data){
    if(!data || !Array.isArray(data.tiles)) throw new Error('Invalid data');

    // Apply layout template and grid variant
    const template = data.layout?.template || 'masonry';
    const variant = data.layout?.gridVariant || 'auto';
    setGridVariant(variant);
    if (typeof window.applyLayout === 'function'){
      try{ window.applyLayout(template); 
    // === Restore captions map from JSON ===
    try{
      if (data.captions && typeof data.captions === 'object'){
        // Clear existing entries to avoid stale keys
        try{ captions.clear(); }catch(_){ captions = new Map(); }
        Object.entries(data.captions).forEach(([k,v])=>{
          if (v && typeof v === 'object'){
            const mapped = (window.__captionKeyMap && window.__captionKeyMap[k]) ? window.__captionKeyMap[k] : k;
            captions.set(mapped, { title: (v.title||''), text: (v.text||'') });
          }
        });
        window.captions = captions;
      }
    }catch(err){ console.warn('Caption import failed:', err); }
}catch(err){ console.warn('applyLayout failed', err); }
    } else {
      // Fallback: cols variants already applied; for hero/checker we can't reconstruct precisely without applyLayout.
    }
    if (data.layout?.gray != null) document.documentElement.style.setProperty('--gray', String(data.layout.gray));
    if (data.layout?.blur != null) document.documentElement.style.setProperty('--blur', String(data.layout.blur));

    // Clear grid
    if (grid) grid.innerHTML = '';

    // Local file resolver
    const needsLocal = data.tiles.some(t => (t.srcType||'') === 'local');
    const rootDirHandle = window.mediaRootHandle || null;
    async function getFileFromRelPath(relPath){
      if (!rootDirHandle || !relPath) return null;
      const parts = relPath.split('/').filter(Boolean);
      let dir = rootDirHandle;
      for (let i = 0; i < parts.length - 1; i++){
        try{ dir = await dir.getDirectoryHandle(parts[i], { create:false }); }catch(_){ return null; }
      }
      const fileName = parts[parts.length - 1];
      try{ const fh = await dir.getFileHandle(fileName, { create:false }); return await fh.getFile(); }catch(_){ return null; }
    }

    for (const t of data.tiles){
      const tile = document.createElement('div'); tile.className = 'tile';
      const origKey = (t.key || t.relPath || t.localName || t.src || (t.kind + ':' + Math.random().toString(36).slice(2)));
      const stableKey = (typeof t.key === 'string' && t.key.startsWith('uid:')) ? t.key : ('uid:' + Math.random().toString(36).slice(2) + Date.now().toString(36));
      // Map legacy keys (filename/relPath/localName) to new uid for caption migration
      window.__captionKeyMap = window.__captionKeyMap || {};
      [t.key, t.relPath, t.localName, origKey].filter(Boolean).forEach(k => { window.__captionKeyMap[k] = stableKey; });
      tile.dataset.key = stableKey;
      if (t.size === 'size-2') tile.classList.add('size-2');
      else if (t.size === 'size-3') tile.classList.add('size-3');
      if (t.tileAR){ try{ tile.style.aspectRatio = t.tileAR; }catch(_){} }
      if (t.arOverride){ tile.dataset.arOverride = t.arOverride; }
      if (t.fit){ tile.dataset.fit = t.fit; if(t.fit==='fitw') tile.classList.add('fitw'); }

      ensureTools(tile);

      let mediaEl;
      const isLocal = (t.srcType||'') === 'local';
      if (t.kind === 'video'){
        mediaEl = document.createElement('video');
        mediaEl.playsInline = true; mediaEl.muted = true; mediaEl.loop = false;
        mediaEl.style.width = '100%'; mediaEl.style.height = '100%';
        mediaEl.style.objectFit = (t.fit || 'cover') || 'cover';
        mediaEl.dataset.srcType = isLocal ? 'local' : 'url';
        mediaEl.dataset.localName = t.localName || '';
        mediaEl.dataset.relPath = t.relPath || t.localName || '';
        mediaEl.dataset.key = stableKey;
        
        // Merge per-tile caption (preferred) into captions map
        try{
          if (typeof captions !== 'undefined') {
            const tTitle = (t && typeof t.title === 'string') ? t.title : '';
            const tDesc  = (t && typeof t.description === 'string') ? t.description : '';
            if (tTitle || tDesc){
              captions.set(stableKey, { title: tTitle, text: tDesc });
            }
          }
        }catch(_){}
    mediaEl.preload = 'metadata';

        let srcUrl = t.src || '';
        if (isLocal && rootDirHandle){
          const f = await getFileFromRelPath(t.relPath || t.localName || '');
          if (f){ srcUrl = URL.createObjectURL(f); }
        }
        if (srcUrl){ mediaEl.src = srcUrl; mediaEl.dataset.origSrc = srcUrl; }

        // Seek to saved thumbTime (or default) and pause; build poster (best effort)
        const seekTime = (typeof t.thumbTime === 'number' && t.thumbTime >= 0) ? t.thumbTime : 0.05;
        mediaEl.addEventListener('loadedmetadata', ()=>{
          try{ mediaEl.currentTime = Math.min(seekTime, Math.max(0, (mediaEl.duration||1)-0.1)); }catch(_){}
        });
        mediaEl.addEventListener('seeked', ()=>{ try{ mediaEl.pause(); }catch(_){} });
        // Optional: capture frame as poster for faster paint
        mediaEl.addEventListener('seeked', ()=>{
          try{
            const r = tile.getBoundingClientRect();
            const cw = Math.max(1, Math.round(r.width));
            const ch = Math.max(1, Math.round(r.height));
            const c = document.createElement('canvas'); c.width = cw; c.height = ch;
            const ctx = c.getContext('2d');
            // Letterbox/cover fit
            const vw = mediaEl.videoWidth || cw, vh = mediaEl.videoHeight || ch;
            const tr = cw/ch, vr = vw/vh;
            let dw, dh, dx, dy;
            if ((t.fit || 'cover') === 'contain'){
              if (vr > tr){ dw = cw; dh = Math.round(cw/vr);} else { dh = ch; dw = Math.round(ch*vr); }
              dx = Math.round((cw-dw)/2); dy = Math.round((ch-dh)/2);
            } else { // cover
              if (vr > tr){ dh = ch; dw = Math.round(ch*vr);} else { dw = cw; dh = Math.round(cw/vr); }
              dx = Math.round((cw-dw)/2); dy = Math.round((ch-dh)/2);
            }
            ctx.drawImage(mediaEl, dx, dy, dw, dh);
            const poster = c.toDataURL('image/jpeg', 0.85);
            mediaEl.setAttribute('poster', poster);
          }catch(err){ /* ignore cross-origin */ }
        });

      } else {
        mediaEl = document.createElement('img');
        mediaEl.style.width = '100%'; mediaEl.style.height = '100%'; mediaEl.style.objectFit = (t.fit || 'cover') || 'cover';
        mediaEl.dataset.srcType = isLocal ? 'local' : 'url';
        mediaEl.dataset.localName = t.localName || '';
        mediaEl.dataset.relPath = t.relPath || t.localName || '';
        mediaEl.dataset.key = stableKey;
        
        // Merge per-tile caption (preferred) into captions map
        try{
          if (typeof captions !== 'undefined') {
            const tTitle = (t && typeof t.title === 'string') ? t.title : '';
            const tDesc  = (t && typeof t.description === 'string') ? t.description : '';
            if (tTitle || tDesc){
              captions.set(stableKey, { title: tTitle, text: tDesc });
            }
          }
        }catch(_){}
    let srcUrl = t.src || '';
        if (isLocal && rootDirHandle){
          const f = await getFileFromRelPath(t.relPath || t.localName || '');
          if (f){ srcUrl = URL.createObjectURL(f); }
        }
        if (srcUrl){ mediaEl.src = srcUrl; mediaEl.dataset.origSrc = srcUrl; }
      }

      tile.appendChild(mediaEl);
      grid?.appendChild(tile);

      if (typeof window.bindTileTools === 'function'){ try{ window.bindTileTools(tile); }catch(_){ } }
    }

    if (typeof window.updateSequenceIndices === 'function'){ try{ window.updateSequenceIndices(); }catch(_){ updateSeqBadges(); } }
    else { updateSeqBadges(); }
    if (typeof window.markUndraggable === 'function'){ try{ window.markUndraggable(grid); }catch(_){} }
    if (typeof window.refreshMedia === 'function'){ try{ window.refreshMedia(); }catch(_){} }

    try { grid?.dispatchEvent(new CustomEvent('board:reloaded', { detail: { tiles: data.tiles } })); } catch(_){}
  }
});
</script>

</body>
</html>
